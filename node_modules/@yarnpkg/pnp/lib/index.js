'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const require$$0 = require('zlib');
const path = require('path');
const module$1 = require('module');
const url = require('url');
const nodeUtils = require('util');
const assert = require('assert');
const fs = require('fs');
const crypto = require('crypto');
const os = require('os');

const _interopDefaultLegacy = e => e && typeof e === 'object' && 'default' in e ? e : { default: e };

const require$$0__default = /*#__PURE__*/_interopDefaultLegacy(require$$0);
const path__default = /*#__PURE__*/_interopDefaultLegacy(path);
const assert__default = /*#__PURE__*/_interopDefaultLegacy(assert);
const fs__default = /*#__PURE__*/_interopDefaultLegacy(fs);

var LinkType = /* @__PURE__ */ ((LinkType2) => {
  LinkType2["HARD"] = `HARD`;
  LinkType2["SOFT"] = `SOFT`;
  return LinkType2;
})(LinkType || {});

const SAFE_TIME = 456789e3;

const PortablePath = {
  root: `/`,
  dot: `.`,
  parent: `..`
};
const Filename = {
  home: `~`,
  nodeModules: `node_modules`,
  manifest: `package.json`,
  lockfile: `yarn.lock`,
  virtual: `__virtual__`,
  pnpJs: `.pnp.js`,
  pnpCjs: `.pnp.cjs`,
  pnpData: `.pnp.data.json`,
  pnpEsmLoader: `.pnp.loader.mjs`,
  rc: `.yarnrc.yml`,
  env: `.env`
};
const npath = Object.create(path__default.default);
const ppath = Object.create(path__default.default.posix);
npath.cwd = () => process.cwd();
ppath.cwd = process.platform === `win32` ? () => toPortablePath(process.cwd()) : process.cwd;
if (process.platform === `win32`) {
  ppath.resolve = (...segments) => {
    if (segments.length > 0 && ppath.isAbsolute(segments[0])) {
      return path__default.default.posix.resolve(...segments);
    } else {
      return path__default.default.posix.resolve(ppath.cwd(), ...segments);
    }
  };
}
const contains = function(pathUtils, from, to) {
  from = pathUtils.normalize(from);
  to = pathUtils.normalize(to);
  if (from === to)
    return `.`;
  if (!from.endsWith(pathUtils.sep))
    from = from + pathUtils.sep;
  if (to.startsWith(from)) {
    return to.slice(from.length);
  } else {
    return null;
  }
};
npath.contains = (from, to) => contains(npath, from, to);
ppath.contains = (from, to) => contains(ppath, from, to);
const WINDOWS_PATH_REGEXP = /^([a-zA-Z]:.*)$/;
const UNC_WINDOWS_PATH_REGEXP = /^\/\/(\.\/)?(.*)$/;
const PORTABLE_PATH_REGEXP = /^\/([a-zA-Z]:.*)$/;
const UNC_PORTABLE_PATH_REGEXP = /^\/unc\/(\.dot\/)?(.*)$/;
function fromPortablePathWin32(p) {
  let portablePathMatch, uncPortablePathMatch;
  if (portablePathMatch = p.match(PORTABLE_PATH_REGEXP))
    p = portablePathMatch[1];
  else if (uncPortablePathMatch = p.match(UNC_PORTABLE_PATH_REGEXP))
    p = `\\\\${uncPortablePathMatch[1] ? `.\\` : ``}${uncPortablePathMatch[2]}`;
  else
    return p;
  return p.replace(/\//g, `\\`);
}
function toPortablePathWin32(p) {
  p = p.replace(/\\/g, `/`);
  let windowsPathMatch, uncWindowsPathMatch;
  if (windowsPathMatch = p.match(WINDOWS_PATH_REGEXP))
    p = `/${windowsPathMatch[1]}`;
  else if (uncWindowsPathMatch = p.match(UNC_WINDOWS_PATH_REGEXP))
    p = `/unc/${uncWindowsPathMatch[1] ? `.dot/` : ``}${uncWindowsPathMatch[2]}`;
  return p;
}
const toPortablePath = process.platform === `win32` ? toPortablePathWin32 : (p) => p;
const fromPortablePath = process.platform === `win32` ? fromPortablePathWin32 : (p) => p;
npath.fromPortablePath = fromPortablePath;
npath.toPortablePath = toPortablePath;
function convertPath(targetPathUtils, sourcePath) {
  return targetPathUtils === npath ? fromPortablePath(sourcePath) : toPortablePath(sourcePath);
}

const defaultTime = new Date(SAFE_TIME * 1e3);
const defaultTimeMs = defaultTime.getTime();
async function copyPromise(destinationFs, destination, sourceFs, source, opts) {
  const normalizedDestination = destinationFs.pathUtils.normalize(destination);
  const normalizedSource = sourceFs.pathUtils.normalize(source);
  const prelayout = [];
  const postlayout = [];
  const { atime, mtime } = opts.stableTime ? { atime: defaultTime, mtime: defaultTime } : await sourceFs.lstatPromise(normalizedSource);
  await destinationFs.mkdirpPromise(destinationFs.pathUtils.dirname(destination), { utimes: [atime, mtime] });
  await copyImpl(prelayout, postlayout, destinationFs, normalizedDestination, sourceFs, normalizedSource, { ...opts, didParentExist: true });
  for (const operation of prelayout)
    await operation();
  await Promise.all(postlayout.map((operation) => {
    return operation();
  }));
}
async function copyImpl(prelayout, postlayout, destinationFs, destination, sourceFs, source, opts) {
  const destinationStat = opts.didParentExist ? await maybeLStat(destinationFs, destination) : null;
  const sourceStat = await sourceFs.lstatPromise(source);
  const { atime, mtime } = opts.stableTime ? { atime: defaultTime, mtime: defaultTime } : sourceStat;
  let updated;
  switch (true) {
    case sourceStat.isDirectory():
      {
        updated = await copyFolder(prelayout, postlayout, destinationFs, destination, destinationStat, sourceFs, source, sourceStat, opts);
      }
      break;
    case sourceStat.isFile():
      {
        updated = await copyFile(prelayout, postlayout, destinationFs, destination, destinationStat, sourceFs, source, sourceStat, opts);
      }
      break;
    case sourceStat.isSymbolicLink():
      {
        updated = await copySymlink(prelayout, postlayout, destinationFs, destination, destinationStat, sourceFs, source, sourceStat, opts);
      }
      break;
    default: {
      throw new Error(`Unsupported file type (${sourceStat.mode})`);
    }
  }
  if (opts.linkStrategy?.type !== `HardlinkFromIndex` || !sourceStat.isFile()) {
    if (updated || destinationStat?.mtime?.getTime() !== mtime.getTime() || destinationStat?.atime?.getTime() !== atime.getTime()) {
      postlayout.push(() => destinationFs.lutimesPromise(destination, atime, mtime));
      updated = true;
    }
    if (destinationStat === null || (destinationStat.mode & 511) !== (sourceStat.mode & 511)) {
      postlayout.push(() => destinationFs.chmodPromise(destination, sourceStat.mode & 511));
      updated = true;
    }
  }
  return updated;
}
async function maybeLStat(baseFs, p) {
  try {
    return await baseFs.lstatPromise(p);
  } catch (e) {
    return null;
  }
}
async function copyFolder(prelayout, postlayout, destinationFs, destination, destinationStat, sourceFs, source, sourceStat, opts) {
  if (destinationStat !== null && !destinationStat.isDirectory()) {
    if (opts.overwrite) {
      prelayout.push(async () => destinationFs.removePromise(destination));
      destinationStat = null;
    } else {
      return false;
    }
  }
  let updated = false;
  if (destinationStat === null) {
    prelayout.push(async () => {
      try {
        await destinationFs.mkdirPromise(destination, { mode: sourceStat.mode });
      } catch (err) {
        if (err.code !== `EEXIST`) {
          throw err;
        }
      }
    });
    updated = true;
  }
  const entries = await sourceFs.readdirPromise(source);
  const nextOpts = opts.didParentExist && !destinationStat ? { ...opts, didParentExist: false } : opts;
  if (opts.stableSort) {
    for (const entry of entries.sort()) {
      if (await copyImpl(prelayout, postlayout, destinationFs, destinationFs.pathUtils.join(destination, entry), sourceFs, sourceFs.pathUtils.join(source, entry), nextOpts)) {
        updated = true;
      }
    }
  } else {
    const entriesUpdateStatus = await Promise.all(entries.map(async (entry) => {
      await copyImpl(prelayout, postlayout, destinationFs, destinationFs.pathUtils.join(destination, entry), sourceFs, sourceFs.pathUtils.join(source, entry), nextOpts);
    }));
    if (entriesUpdateStatus.some((status) => status)) {
      updated = true;
    }
  }
  return updated;
}
async function copyFileViaIndex(prelayout, postlayout, destinationFs, destination, destinationStat, sourceFs, source, sourceStat, opts, linkStrategy) {
  const sourceHash = await sourceFs.checksumFilePromise(source, { algorithm: `sha1` });
  const defaultMode = 420;
  const sourceMode = sourceStat.mode & 511;
  const indexFileName = `${sourceHash}${sourceMode !== defaultMode ? sourceMode.toString(8) : ``}`;
  const indexPath = destinationFs.pathUtils.join(linkStrategy.indexPath, sourceHash.slice(0, 2), `${indexFileName}.dat`);
  let AtomicBehavior;
  ((AtomicBehavior2) => {
    AtomicBehavior2[AtomicBehavior2["Lock"] = 0] = "Lock";
    AtomicBehavior2[AtomicBehavior2["Rename"] = 1] = "Rename";
  })(AtomicBehavior || (AtomicBehavior = {}));
  let atomicBehavior = 1 /* Rename */;
  let indexStat = await maybeLStat(destinationFs, indexPath);
  if (destinationStat) {
    const isDestinationHardlinkedFromIndex = indexStat && destinationStat.dev === indexStat.dev && destinationStat.ino === indexStat.ino;
    const isIndexModified = indexStat?.mtimeMs !== defaultTimeMs;
    if (isDestinationHardlinkedFromIndex) {
      if (isIndexModified && linkStrategy.autoRepair) {
        atomicBehavior = 0 /* Lock */;
        indexStat = null;
      }
    }
    if (!isDestinationHardlinkedFromIndex) {
      if (opts.overwrite) {
        prelayout.push(async () => destinationFs.removePromise(destination));
        destinationStat = null;
      } else {
        return false;
      }
    }
  }
  const tempPath = !indexStat && atomicBehavior === 1 /* Rename */ ? `${indexPath}.${Math.floor(Math.random() * 4294967296).toString(16).padStart(8, `0`)}` : null;
  let tempPathCleaned = false;
  prelayout.push(async () => {
    if (!indexStat) {
      if (atomicBehavior === 0 /* Lock */) {
        await destinationFs.lockPromise(indexPath, async () => {
          const content = await sourceFs.readFilePromise(source);
          await destinationFs.writeFilePromise(indexPath, content);
        });
      }
      if (atomicBehavior === 1 /* Rename */ && tempPath) {
        const content = await sourceFs.readFilePromise(source);
        await destinationFs.writeFilePromise(tempPath, content);
        try {
          await destinationFs.linkPromise(tempPath, indexPath);
        } catch (err) {
          if (err.code === `EEXIST`) {
            tempPathCleaned = true;
            await destinationFs.unlinkPromise(tempPath);
          } else {
            throw err;
          }
        }
      }
    }
    if (!destinationStat) {
      await destinationFs.linkPromise(indexPath, destination);
    }
  });
  postlayout.push(async () => {
    if (!indexStat) {
      await destinationFs.lutimesPromise(indexPath, defaultTime, defaultTime);
      if (sourceMode !== defaultMode) {
        await destinationFs.chmodPromise(indexPath, sourceMode);
      }
    }
    if (tempPath && !tempPathCleaned) {
      await destinationFs.unlinkPromise(tempPath);
    }
  });
  return false;
}
async function copyFileDirect(prelayout, postlayout, destinationFs, destination, destinationStat, sourceFs, source, sourceStat, opts) {
  if (destinationStat !== null) {
    if (opts.overwrite) {
      prelayout.push(async () => destinationFs.removePromise(destination));
      destinationStat = null;
    } else {
      return false;
    }
  }
  prelayout.push(async () => {
    const content = await sourceFs.readFilePromise(source);
    await destinationFs.writeFilePromise(destination, content);
  });
  return true;
}
async function copyFile(prelayout, postlayout, destinationFs, destination, destinationStat, sourceFs, source, sourceStat, opts) {
  if (opts.linkStrategy?.type === `HardlinkFromIndex`) {
    return copyFileViaIndex(prelayout, postlayout, destinationFs, destination, destinationStat, sourceFs, source, sourceStat, opts, opts.linkStrategy);
  } else {
    return copyFileDirect(prelayout, postlayout, destinationFs, destination, destinationStat, sourceFs, source, sourceStat, opts);
  }
}
async function copySymlink(prelayout, postlayout, destinationFs, destination, destinationStat, sourceFs, source, sourceStat, opts) {
  if (destinationStat !== null) {
    if (opts.overwrite) {
      prelayout.push(async () => destinationFs.removePromise(destination));
      destinationStat = null;
    } else {
      return false;
    }
  }
  prelayout.push(async () => {
    await destinationFs.symlinkPromise(convertPath(destinationFs.pathUtils, await sourceFs.readlinkPromise(source)), destination);
  });
  return true;
}

class FakeFS {
  constructor(pathUtils) {
    this.pathUtils = pathUtils;
  }
  async *genTraversePromise(init, { stableSort = false } = {}) {
    const stack = [init];
    while (stack.length > 0) {
      const p = stack.shift();
      const entry = await this.lstatPromise(p);
      if (entry.isDirectory()) {
        const entries = await this.readdirPromise(p);
        if (stableSort) {
          for (const entry2 of entries.sort()) {
            stack.push(this.pathUtils.join(p, entry2));
          }
        } else {
          throw new Error(`Not supported`);
        }
      } else {
        yield p;
      }
    }
  }
  async checksumFilePromise(path, { algorithm = `sha512` } = {}) {
    const fd = await this.openPromise(path, `r`);
    try {
      const CHUNK_SIZE = 65536;
      const chunk = Buffer.allocUnsafeSlow(CHUNK_SIZE);
      const hash = crypto.createHash(algorithm);
      let bytesRead = 0;
      while ((bytesRead = await this.readPromise(fd, chunk, 0, CHUNK_SIZE)) !== 0)
        hash.update(bytesRead === CHUNK_SIZE ? chunk : chunk.slice(0, bytesRead));
      return hash.digest(`hex`);
    } finally {
      await this.closePromise(fd);
    }
  }
  async removePromise(p, { recursive = true, maxRetries = 5 } = {}) {
    let stat;
    try {
      stat = await this.lstatPromise(p);
    } catch (error) {
      if (error.code === `ENOENT`) {
        return;
      } else {
        throw error;
      }
    }
    if (stat.isDirectory()) {
      if (recursive) {
        const entries = await this.readdirPromise(p);
        await Promise.all(entries.map((entry) => {
          return this.removePromise(this.pathUtils.resolve(p, entry));
        }));
      }
      for (let t = 0; t <= maxRetries; t++) {
        try {
          await this.rmdirPromise(p);
          break;
        } catch (error) {
          if (error.code !== `EBUSY` && error.code !== `ENOTEMPTY`) {
            throw error;
          } else if (t < maxRetries) {
            await new Promise((resolve) => setTimeout(resolve, t * 100));
          }
        }
      }
    } else {
      await this.unlinkPromise(p);
    }
  }
  removeSync(p, { recursive = true } = {}) {
    let stat;
    try {
      stat = this.lstatSync(p);
    } catch (error) {
      if (error.code === `ENOENT`) {
        return;
      } else {
        throw error;
      }
    }
    if (stat.isDirectory()) {
      if (recursive)
        for (const entry of this.readdirSync(p))
          this.removeSync(this.pathUtils.resolve(p, entry));
      this.rmdirSync(p);
    } else {
      this.unlinkSync(p);
    }
  }
  async mkdirpPromise(p, { chmod, utimes } = {}) {
    p = this.resolve(p);
    if (p === this.pathUtils.dirname(p))
      return void 0;
    const parts = p.split(this.pathUtils.sep);
    let createdDirectory;
    for (let u = 2; u <= parts.length; ++u) {
      const subPath = parts.slice(0, u).join(this.pathUtils.sep);
      if (!this.existsSync(subPath)) {
        try {
          await this.mkdirPromise(subPath);
        } catch (error) {
          if (error.code === `EEXIST`) {
            continue;
          } else {
            throw error;
          }
        }
        createdDirectory ??= subPath;
        if (chmod != null)
          await this.chmodPromise(subPath, chmod);
        if (utimes != null) {
          await this.utimesPromise(subPath, utimes[0], utimes[1]);
        } else {
          const parentStat = await this.statPromise(this.pathUtils.dirname(subPath));
          await this.utimesPromise(subPath, parentStat.atime, parentStat.mtime);
        }
      }
    }
    return createdDirectory;
  }
  mkdirpSync(p, { chmod, utimes } = {}) {
    p = this.resolve(p);
    if (p === this.pathUtils.dirname(p))
      return void 0;
    const parts = p.split(this.pathUtils.sep);
    let createdDirectory;
    for (let u = 2; u <= parts.length; ++u) {
      const subPath = parts.slice(0, u).join(this.pathUtils.sep);
      if (!this.existsSync(subPath)) {
        try {
          this.mkdirSync(subPath);
        } catch (error) {
          if (error.code === `EEXIST`) {
            continue;
          } else {
            throw error;
          }
        }
        createdDirectory ??= subPath;
        if (chmod != null)
          this.chmodSync(subPath, chmod);
        if (utimes != null) {
          this.utimesSync(subPath, utimes[0], utimes[1]);
        } else {
          const parentStat = this.statSync(this.pathUtils.dirname(subPath));
          this.utimesSync(subPath, parentStat.atime, parentStat.mtime);
        }
      }
    }
    return createdDirectory;
  }
  async copyPromise(destination, source, { baseFs = this, overwrite = true, stableSort = false, stableTime = false, linkStrategy = null } = {}) {
    return await copyPromise(this, destination, baseFs, source, { overwrite, stableSort, stableTime, linkStrategy });
  }
  copySync(destination, source, { baseFs = this, overwrite = true } = {}) {
    const stat = baseFs.lstatSync(source);
    const exists = this.existsSync(destination);
    if (stat.isDirectory()) {
      this.mkdirpSync(destination);
      const directoryListing = baseFs.readdirSync(source);
      for (const entry of directoryListing) {
        this.copySync(this.pathUtils.join(destination, entry), baseFs.pathUtils.join(source, entry), { baseFs, overwrite });
      }
    } else if (stat.isFile()) {
      if (!exists || overwrite) {
        if (exists)
          this.removeSync(destination);
        const content = baseFs.readFileSync(source);
        this.writeFileSync(destination, content);
      }
    } else if (stat.isSymbolicLink()) {
      if (!exists || overwrite) {
        if (exists)
          this.removeSync(destination);
        const target = baseFs.readlinkSync(source);
        this.symlinkSync(convertPath(this.pathUtils, target), destination);
      }
    } else {
      throw new Error(`Unsupported file type (file: ${source}, mode: 0o${stat.mode.toString(8).padStart(6, `0`)})`);
    }
    const mode = stat.mode & 511;
    this.chmodSync(destination, mode);
  }
  async changeFilePromise(p, content, opts = {}) {
    if (Buffer.isBuffer(content)) {
      return this.changeFileBufferPromise(p, content, opts);
    } else {
      return this.changeFileTextPromise(p, content, opts);
    }
  }
  async changeFileBufferPromise(p, content, { mode } = {}) {
    let current = Buffer.alloc(0);
    try {
      current = await this.readFilePromise(p);
    } catch (error) {
    }
    if (Buffer.compare(current, content) === 0)
      return;
    await this.writeFilePromise(p, content, { mode });
  }
  async changeFileTextPromise(p, content, { automaticNewlines, mode } = {}) {
    let current = ``;
    try {
      current = await this.readFilePromise(p, `utf8`);
    } catch (error) {
    }
    const normalizedContent = automaticNewlines ? normalizeLineEndings(current, content) : content;
    if (current === normalizedContent)
      return;
    await this.writeFilePromise(p, normalizedContent, { mode });
  }
  changeFileSync(p, content, opts = {}) {
    if (Buffer.isBuffer(content)) {
      return this.changeFileBufferSync(p, content, opts);
    } else {
      return this.changeFileTextSync(p, content, opts);
    }
  }
  changeFileBufferSync(p, content, { mode } = {}) {
    let current = Buffer.alloc(0);
    try {
      current = this.readFileSync(p);
    } catch (error) {
    }
    if (Buffer.compare(current, content) === 0)
      return;
    this.writeFileSync(p, content, { mode });
  }
  changeFileTextSync(p, content, { automaticNewlines = false, mode } = {}) {
    let current = ``;
    try {
      current = this.readFileSync(p, `utf8`);
    } catch (error) {
    }
    const normalizedContent = automaticNewlines ? normalizeLineEndings(current, content) : content;
    if (current === normalizedContent)
      return;
    this.writeFileSync(p, normalizedContent, { mode });
  }
  async movePromise(fromP, toP) {
    try {
      await this.renamePromise(fromP, toP);
    } catch (error) {
      if (error.code === `EXDEV`) {
        await this.copyPromise(toP, fromP);
        await this.removePromise(fromP);
      } else {
        throw error;
      }
    }
  }
  moveSync(fromP, toP) {
    try {
      this.renameSync(fromP, toP);
    } catch (error) {
      if (error.code === `EXDEV`) {
        this.copySync(toP, fromP);
        this.removeSync(fromP);
      } else {
        throw error;
      }
    }
  }
  async lockPromise(affectedPath, callback) {
    const lockPath = `${affectedPath}.flock`;
    const interval = 1e3 / 60;
    const startTime = Date.now();
    let fd = null;
    const isAlive = async () => {
      let pid;
      try {
        [pid] = await this.readJsonPromise(lockPath);
      } catch (error) {
        return Date.now() - startTime < 500;
      }
      try {
        process.kill(pid, 0);
        return true;
      } catch (error) {
        return false;
      }
    };
    while (fd === null) {
      try {
        fd = await this.openPromise(lockPath, `wx`);
      } catch (error) {
        if (error.code === `EEXIST`) {
          if (!await isAlive()) {
            try {
              await this.unlinkPromise(lockPath);
              continue;
            } catch (error2) {
            }
          }
          if (Date.now() - startTime < 60 * 1e3) {
            await new Promise((resolve) => setTimeout(resolve, interval));
          } else {
            throw new Error(`Couldn't acquire a lock in a reasonable time (via ${lockPath})`);
          }
        } else {
          throw error;
        }
      }
    }
    await this.writePromise(fd, JSON.stringify([process.pid]));
    try {
      return await callback();
    } finally {
      try {
        await this.closePromise(fd);
        await this.unlinkPromise(lockPath);
      } catch (error) {
      }
    }
  }
  async readJsonPromise(p) {
    const content = await this.readFilePromise(p, `utf8`);
    try {
      return JSON.parse(content);
    } catch (error) {
      error.message += ` (in ${p})`;
      throw error;
    }
  }
  readJsonSync(p) {
    const content = this.readFileSync(p, `utf8`);
    try {
      return JSON.parse(content);
    } catch (error) {
      error.message += ` (in ${p})`;
      throw error;
    }
  }
  async writeJsonPromise(p, data, { compact = false } = {}) {
    const space = compact ? 0 : 2;
    return await this.writeFilePromise(p, `${JSON.stringify(data, null, space)}
`);
  }
  writeJsonSync(p, data, { compact = false } = {}) {
    const space = compact ? 0 : 2;
    return this.writeFileSync(p, `${JSON.stringify(data, null, space)}
`);
  }
  async preserveTimePromise(p, cb) {
    const stat = await this.lstatPromise(p);
    const result = await cb();
    if (typeof result !== `undefined`)
      p = result;
    await this.lutimesPromise(p, stat.atime, stat.mtime);
  }
  async preserveTimeSync(p, cb) {
    const stat = this.lstatSync(p);
    const result = cb();
    if (typeof result !== `undefined`)
      p = result;
    this.lutimesSync(p, stat.atime, stat.mtime);
  }
}
class BasePortableFakeFS extends FakeFS {
  constructor() {
    super(ppath);
  }
}
function getEndOfLine(content) {
  const matches = content.match(/\r?\n/g);
  if (matches === null)
    return os.EOL;
  const crlf = matches.filter((nl) => nl === `\r
`).length;
  const lf = matches.length - crlf;
  return crlf > lf ? `\r
` : `
`;
}
function normalizeLineEndings(originalContent, newContent) {
  return newContent.replace(/\r?\n/g, getEndOfLine(originalContent));
}

class ProxiedFS extends FakeFS {
  getExtractHint(hints) {
    return this.baseFs.getExtractHint(hints);
  }
  resolve(path) {
    return this.mapFromBase(this.baseFs.resolve(this.mapToBase(path)));
  }
  getRealPath() {
    return this.mapFromBase(this.baseFs.getRealPath());
  }
  async openPromise(p, flags, mode) {
    return this.baseFs.openPromise(this.mapToBase(p), flags, mode);
  }
  openSync(p, flags, mode) {
    return this.baseFs.openSync(this.mapToBase(p), flags, mode);
  }
  async opendirPromise(p, opts) {
    return Object.assign(await this.baseFs.opendirPromise(this.mapToBase(p), opts), { path: p });
  }
  opendirSync(p, opts) {
    return Object.assign(this.baseFs.opendirSync(this.mapToBase(p), opts), { path: p });
  }
  async readPromise(fd, buffer, offset, length, position) {
    return await this.baseFs.readPromise(fd, buffer, offset, length, position);
  }
  readSync(fd, buffer, offset, length, position) {
    return this.baseFs.readSync(fd, buffer, offset, length, position);
  }
  async writePromise(fd, buffer, offset, length, position) {
    if (typeof buffer === `string`) {
      return await this.baseFs.writePromise(fd, buffer, offset);
    } else {
      return await this.baseFs.writePromise(fd, buffer, offset, length, position);
    }
  }
  writeSync(fd, buffer, offset, length, position) {
    if (typeof buffer === `string`) {
      return this.baseFs.writeSync(fd, buffer, offset);
    } else {
      return this.baseFs.writeSync(fd, buffer, offset, length, position);
    }
  }
  async closePromise(fd) {
    return this.baseFs.closePromise(fd);
  }
  closeSync(fd) {
    this.baseFs.closeSync(fd);
  }
  createReadStream(p, opts) {
    return this.baseFs.createReadStream(p !== null ? this.mapToBase(p) : p, opts);
  }
  createWriteStream(p, opts) {
    return this.baseFs.createWriteStream(p !== null ? this.mapToBase(p) : p, opts);
  }
  async realpathPromise(p) {
    return this.mapFromBase(await this.baseFs.realpathPromise(this.mapToBase(p)));
  }
  realpathSync(p) {
    return this.mapFromBase(this.baseFs.realpathSync(this.mapToBase(p)));
  }
  async existsPromise(p) {
    return this.baseFs.existsPromise(this.mapToBase(p));
  }
  existsSync(p) {
    return this.baseFs.existsSync(this.mapToBase(p));
  }
  accessSync(p, mode) {
    return this.baseFs.accessSync(this.mapToBase(p), mode);
  }
  async accessPromise(p, mode) {
    return this.baseFs.accessPromise(this.mapToBase(p), mode);
  }
  async statPromise(p, opts) {
    return this.baseFs.statPromise(this.mapToBase(p), opts);
  }
  statSync(p, opts) {
    return this.baseFs.statSync(this.mapToBase(p), opts);
  }
  async fstatPromise(fd, opts) {
    return this.baseFs.fstatPromise(fd, opts);
  }
  fstatSync(fd, opts) {
    return this.baseFs.fstatSync(fd, opts);
  }
  lstatPromise(p, opts) {
    return this.baseFs.lstatPromise(this.mapToBase(p), opts);
  }
  lstatSync(p, opts) {
    return this.baseFs.lstatSync(this.mapToBase(p), opts);
  }
  async fchmodPromise(fd, mask) {
    return this.baseFs.fchmodPromise(fd, mask);
  }
  fchmodSync(fd, mask) {
    return this.baseFs.fchmodSync(fd, mask);
  }
  async chmodPromise(p, mask) {
    return this.baseFs.chmodPromise(this.mapToBase(p), mask);
  }
  chmodSync(p, mask) {
    return this.baseFs.chmodSync(this.mapToBase(p), mask);
  }
  async fchownPromise(fd, uid, gid) {
    return this.baseFs.fchownPromise(fd, uid, gid);
  }
  fchownSync(fd, uid, gid) {
    return this.baseFs.fchownSync(fd, uid, gid);
  }
  async chownPromise(p, uid, gid) {
    return this.baseFs.chownPromise(this.mapToBase(p), uid, gid);
  }
  chownSync(p, uid, gid) {
    return this.baseFs.chownSync(this.mapToBase(p), uid, gid);
  }
  async renamePromise(oldP, newP) {
    return this.baseFs.renamePromise(this.mapToBase(oldP), this.mapToBase(newP));
  }
  renameSync(oldP, newP) {
    return this.baseFs.renameSync(this.mapToBase(oldP), this.mapToBase(newP));
  }
  async copyFilePromise(sourceP, destP, flags = 0) {
    return this.baseFs.copyFilePromise(this.mapToBase(sourceP), this.mapToBase(destP), flags);
  }
  copyFileSync(sourceP, destP, flags = 0) {
    return this.baseFs.copyFileSync(this.mapToBase(sourceP), this.mapToBase(destP), flags);
  }
  async appendFilePromise(p, content, opts) {
    return this.baseFs.appendFilePromise(this.fsMapToBase(p), content, opts);
  }
  appendFileSync(p, content, opts) {
    return this.baseFs.appendFileSync(this.fsMapToBase(p), content, opts);
  }
  async writeFilePromise(p, content, opts) {
    return this.baseFs.writeFilePromise(this.fsMapToBase(p), content, opts);
  }
  writeFileSync(p, content, opts) {
    return this.baseFs.writeFileSync(this.fsMapToBase(p), content, opts);
  }
  async unlinkPromise(p) {
    return this.baseFs.unlinkPromise(this.mapToBase(p));
  }
  unlinkSync(p) {
    return this.baseFs.unlinkSync(this.mapToBase(p));
  }
  async utimesPromise(p, atime, mtime) {
    return this.baseFs.utimesPromise(this.mapToBase(p), atime, mtime);
  }
  utimesSync(p, atime, mtime) {
    return this.baseFs.utimesSync(this.mapToBase(p), atime, mtime);
  }
  async lutimesPromise(p, atime, mtime) {
    return this.baseFs.lutimesPromise(this.mapToBase(p), atime, mtime);
  }
  lutimesSync(p, atime, mtime) {
    return this.baseFs.lutimesSync(this.mapToBase(p), atime, mtime);
  }
  async mkdirPromise(p, opts) {
    return this.baseFs.mkdirPromise(this.mapToBase(p), opts);
  }
  mkdirSync(p, opts) {
    return this.baseFs.mkdirSync(this.mapToBase(p), opts);
  }
  async rmdirPromise(p, opts) {
    return this.baseFs.rmdirPromise(this.mapToBase(p), opts);
  }
  rmdirSync(p, opts) {
    return this.baseFs.rmdirSync(this.mapToBase(p), opts);
  }
  async linkPromise(existingP, newP) {
    return this.baseFs.linkPromise(this.mapToBase(existingP), this.mapToBase(newP));
  }
  linkSync(existingP, newP) {
    return this.baseFs.linkSync(this.mapToBase(existingP), this.mapToBase(newP));
  }
  async symlinkPromise(target, p, type) {
    const mappedP = this.mapToBase(p);
    if (this.pathUtils.isAbsolute(target))
      return this.baseFs.symlinkPromise(this.mapToBase(target), mappedP, type);
    const mappedAbsoluteTarget = this.mapToBase(this.pathUtils.join(this.pathUtils.dirname(p), target));
    const mappedTarget = this.baseFs.pathUtils.relative(this.baseFs.pathUtils.dirname(mappedP), mappedAbsoluteTarget);
    return this.baseFs.symlinkPromise(mappedTarget, mappedP, type);
  }
  symlinkSync(target, p, type) {
    const mappedP = this.mapToBase(p);
    if (this.pathUtils.isAbsolute(target))
      return this.baseFs.symlinkSync(this.mapToBase(target), mappedP, type);
    const mappedAbsoluteTarget = this.mapToBase(this.pathUtils.join(this.pathUtils.dirname(p), target));
    const mappedTarget = this.baseFs.pathUtils.relative(this.baseFs.pathUtils.dirname(mappedP), mappedAbsoluteTarget);
    return this.baseFs.symlinkSync(mappedTarget, mappedP, type);
  }
  async readFilePromise(p, encoding) {
    return this.baseFs.readFilePromise(this.fsMapToBase(p), encoding);
  }
  readFileSync(p, encoding) {
    return this.baseFs.readFileSync(this.fsMapToBase(p), encoding);
  }
  readdirPromise(p, opts) {
    return this.baseFs.readdirPromise(this.mapToBase(p), opts);
  }
  readdirSync(p, opts) {
    return this.baseFs.readdirSync(this.mapToBase(p), opts);
  }
  async readlinkPromise(p) {
    return this.mapFromBase(await this.baseFs.readlinkPromise(this.mapToBase(p)));
  }
  readlinkSync(p) {
    return this.mapFromBase(this.baseFs.readlinkSync(this.mapToBase(p)));
  }
  async truncatePromise(p, len) {
    return this.baseFs.truncatePromise(this.mapToBase(p), len);
  }
  truncateSync(p, len) {
    return this.baseFs.truncateSync(this.mapToBase(p), len);
  }
  async ftruncatePromise(fd, len) {
    return this.baseFs.ftruncatePromise(fd, len);
  }
  ftruncateSync(fd, len) {
    return this.baseFs.ftruncateSync(fd, len);
  }
  watch(p, a, b) {
    return this.baseFs.watch(
      this.mapToBase(p),
      a,
      b
    );
  }
  watchFile(p, a, b) {
    return this.baseFs.watchFile(
      this.mapToBase(p),
      a,
      b
    );
  }
  unwatchFile(p, cb) {
    return this.baseFs.unwatchFile(this.mapToBase(p), cb);
  }
  fsMapToBase(p) {
    if (typeof p === `number`) {
      return p;
    } else {
      return this.mapToBase(p);
    }
  }
}

function direntToPortable(dirent) {
  const portableDirent = dirent;
  if (typeof dirent.path === `string`)
    portableDirent.path = npath.toPortablePath(dirent.path);
  return portableDirent;
}
class NodeFS extends BasePortableFakeFS {
  constructor(realFs = fs__default.default) {
    super();
    this.realFs = realFs;
  }
  getExtractHint() {
    return false;
  }
  getRealPath() {
    return PortablePath.root;
  }
  resolve(p) {
    return ppath.resolve(p);
  }
  async openPromise(p, flags, mode) {
    return await new Promise((resolve, reject) => {
      this.realFs.open(npath.fromPortablePath(p), flags, mode, this.makeCallback(resolve, reject));
    });
  }
  openSync(p, flags, mode) {
    return this.realFs.openSync(npath.fromPortablePath(p), flags, mode);
  }
  async opendirPromise(p, opts) {
    return await new Promise((resolve, reject) => {
      if (typeof opts !== `undefined`) {
        this.realFs.opendir(npath.fromPortablePath(p), opts, this.makeCallback(resolve, reject));
      } else {
        this.realFs.opendir(npath.fromPortablePath(p), this.makeCallback(resolve, reject));
      }
    }).then((dir) => {
      const dirWithFixedPath = dir;
      Object.defineProperty(dirWithFixedPath, `path`, {
        value: p,
        configurable: true,
        writable: true
      });
      return dirWithFixedPath;
    });
  }
  opendirSync(p, opts) {
    const dir = typeof opts !== `undefined` ? this.realFs.opendirSync(npath.fromPortablePath(p), opts) : this.realFs.opendirSync(npath.fromPortablePath(p));
    const dirWithFixedPath = dir;
    Object.defineProperty(dirWithFixedPath, `path`, {
      value: p,
      configurable: true,
      writable: true
    });
    return dirWithFixedPath;
  }
  async readPromise(fd, buffer, offset = 0, length = 0, position = -1) {
    return await new Promise((resolve, reject) => {
      this.realFs.read(fd, buffer, offset, length, position, (error, bytesRead) => {
        if (error) {
          reject(error);
        } else {
          resolve(bytesRead);
        }
      });
    });
  }
  readSync(fd, buffer, offset, length, position) {
    return this.realFs.readSync(fd, buffer, offset, length, position);
  }
  async writePromise(fd, buffer, offset, length, position) {
    return await new Promise((resolve, reject) => {
      if (typeof buffer === `string`) {
        return this.realFs.write(fd, buffer, offset, this.makeCallback(resolve, reject));
      } else {
        return this.realFs.write(fd, buffer, offset, length, position, this.makeCallback(resolve, reject));
      }
    });
  }
  writeSync(fd, buffer, offset, length, position) {
    if (typeof buffer === `string`) {
      return this.realFs.writeSync(fd, buffer, offset);
    } else {
      return this.realFs.writeSync(fd, buffer, offset, length, position);
    }
  }
  async closePromise(fd) {
    await new Promise((resolve, reject) => {
      this.realFs.close(fd, this.makeCallback(resolve, reject));
    });
  }
  closeSync(fd) {
    this.realFs.closeSync(fd);
  }
  createReadStream(p, opts) {
    const realPath = p !== null ? npath.fromPortablePath(p) : p;
    return this.realFs.createReadStream(realPath, opts);
  }
  createWriteStream(p, opts) {
    const realPath = p !== null ? npath.fromPortablePath(p) : p;
    return this.realFs.createWriteStream(realPath, opts);
  }
  async realpathPromise(p) {
    return await new Promise((resolve, reject) => {
      this.realFs.realpath(npath.fromPortablePath(p), {}, this.makeCallback(resolve, reject));
    }).then((path) => {
      return npath.toPortablePath(path);
    });
  }
  realpathSync(p) {
    return npath.toPortablePath(this.realFs.realpathSync(npath.fromPortablePath(p), {}));
  }
  async existsPromise(p) {
    return await new Promise((resolve) => {
      this.realFs.exists(npath.fromPortablePath(p), resolve);
    });
  }
  accessSync(p, mode) {
    return this.realFs.accessSync(npath.fromPortablePath(p), mode);
  }
  async accessPromise(p, mode) {
    return await new Promise((resolve, reject) => {
      this.realFs.access(npath.fromPortablePath(p), mode, this.makeCallback(resolve, reject));
    });
  }
  existsSync(p) {
    return this.realFs.existsSync(npath.fromPortablePath(p));
  }
  async statPromise(p, opts) {
    return await new Promise((resolve, reject) => {
      if (opts) {
        this.realFs.stat(npath.fromPortablePath(p), opts, this.makeCallback(resolve, reject));
      } else {
        this.realFs.stat(npath.fromPortablePath(p), this.makeCallback(resolve, reject));
      }
    });
  }
  statSync(p, opts) {
    if (opts) {
      return this.realFs.statSync(npath.fromPortablePath(p), opts);
    } else {
      return this.realFs.statSync(npath.fromPortablePath(p));
    }
  }
  async fstatPromise(fd, opts) {
    return await new Promise((resolve, reject) => {
      if (opts) {
        this.realFs.fstat(fd, opts, this.makeCallback(resolve, reject));
      } else {
        this.realFs.fstat(fd, this.makeCallback(resolve, reject));
      }
    });
  }
  fstatSync(fd, opts) {
    if (opts) {
      return this.realFs.fstatSync(fd, opts);
    } else {
      return this.realFs.fstatSync(fd);
    }
  }
  async lstatPromise(p, opts) {
    return await new Promise((resolve, reject) => {
      if (opts) {
        this.realFs.lstat(npath.fromPortablePath(p), opts, this.makeCallback(resolve, reject));
      } else {
        this.realFs.lstat(npath.fromPortablePath(p), this.makeCallback(resolve, reject));
      }
    });
  }
  lstatSync(p, opts) {
    if (opts) {
      return this.realFs.lstatSync(npath.fromPortablePath(p), opts);
    } else {
      return this.realFs.lstatSync(npath.fromPortablePath(p));
    }
  }
  async fchmodPromise(fd, mask) {
    return await new Promise((resolve, reject) => {
      this.realFs.fchmod(fd, mask, this.makeCallback(resolve, reject));
    });
  }
  fchmodSync(fd, mask) {
    return this.realFs.fchmodSync(fd, mask);
  }
  async chmodPromise(p, mask) {
    return await new Promise((resolve, reject) => {
      this.realFs.chmod(npath.fromPortablePath(p), mask, this.makeCallback(resolve, reject));
    });
  }
  chmodSync(p, mask) {
    return this.realFs.chmodSync(npath.fromPortablePath(p), mask);
  }
  async fchownPromise(fd, uid, gid) {
    return await new Promise((resolve, reject) => {
      this.realFs.fchown(fd, uid, gid, this.makeCallback(resolve, reject));
    });
  }
  fchownSync(fd, uid, gid) {
    return this.realFs.fchownSync(fd, uid, gid);
  }
  async chownPromise(p, uid, gid) {
    return await new Promise((resolve, reject) => {
      this.realFs.chown(npath.fromPortablePath(p), uid, gid, this.makeCallback(resolve, reject));
    });
  }
  chownSync(p, uid, gid) {
    return this.realFs.chownSync(npath.fromPortablePath(p), uid, gid);
  }
  async renamePromise(oldP, newP) {
    return await new Promise((resolve, reject) => {
      this.realFs.rename(npath.fromPortablePath(oldP), npath.fromPortablePath(newP), this.makeCallback(resolve, reject));
    });
  }
  renameSync(oldP, newP) {
    return this.realFs.renameSync(npath.fromPortablePath(oldP), npath.fromPortablePath(newP));
  }
  async copyFilePromise(sourceP, destP, flags = 0) {
    return await new Promise((resolve, reject) => {
      this.realFs.copyFile(npath.fromPortablePath(sourceP), npath.fromPortablePath(destP), flags, this.makeCallback(resolve, reject));
    });
  }
  copyFileSync(sourceP, destP, flags = 0) {
    return this.realFs.copyFileSync(npath.fromPortablePath(sourceP), npath.fromPortablePath(destP), flags);
  }
  async appendFilePromise(p, content, opts) {
    return await new Promise((resolve, reject) => {
      const fsNativePath = typeof p === `string` ? npath.fromPortablePath(p) : p;
      if (opts) {
        this.realFs.appendFile(fsNativePath, content, opts, this.makeCallback(resolve, reject));
      } else {
        this.realFs.appendFile(fsNativePath, content, this.makeCallback(resolve, reject));
      }
    });
  }
  appendFileSync(p, content, opts) {
    const fsNativePath = typeof p === `string` ? npath.fromPortablePath(p) : p;
    if (opts) {
      this.realFs.appendFileSync(fsNativePath, content, opts);
    } else {
      this.realFs.appendFileSync(fsNativePath, content);
    }
  }
  async writeFilePromise(p, content, opts) {
    return await new Promise((resolve, reject) => {
      const fsNativePath = typeof p === `string` ? npath.fromPortablePath(p) : p;
      if (opts) {
        this.realFs.writeFile(fsNativePath, content, opts, this.makeCallback(resolve, reject));
      } else {
        this.realFs.writeFile(fsNativePath, content, this.makeCallback(resolve, reject));
      }
    });
  }
  writeFileSync(p, content, opts) {
    const fsNativePath = typeof p === `string` ? npath.fromPortablePath(p) : p;
    if (opts) {
      this.realFs.writeFileSync(fsNativePath, content, opts);
    } else {
      this.realFs.writeFileSync(fsNativePath, content);
    }
  }
  async unlinkPromise(p) {
    return await new Promise((resolve, reject) => {
      this.realFs.unlink(npath.fromPortablePath(p), this.makeCallback(resolve, reject));
    });
  }
  unlinkSync(p) {
    return this.realFs.unlinkSync(npath.fromPortablePath(p));
  }
  async utimesPromise(p, atime, mtime) {
    return await new Promise((resolve, reject) => {
      this.realFs.utimes(npath.fromPortablePath(p), atime, mtime, this.makeCallback(resolve, reject));
    });
  }
  utimesSync(p, atime, mtime) {
    this.realFs.utimesSync(npath.fromPortablePath(p), atime, mtime);
  }
  async lutimesPromise(p, atime, mtime) {
    return await new Promise((resolve, reject) => {
      this.realFs.lutimes(npath.fromPortablePath(p), atime, mtime, this.makeCallback(resolve, reject));
    });
  }
  lutimesSync(p, atime, mtime) {
    this.realFs.lutimesSync(npath.fromPortablePath(p), atime, mtime);
  }
  async mkdirPromise(p, opts) {
    return await new Promise((resolve, reject) => {
      this.realFs.mkdir(npath.fromPortablePath(p), opts, this.makeCallback(resolve, reject));
    });
  }
  mkdirSync(p, opts) {
    return this.realFs.mkdirSync(npath.fromPortablePath(p), opts);
  }
  async rmdirPromise(p, opts) {
    return await new Promise((resolve, reject) => {
      if (opts) {
        this.realFs.rmdir(npath.fromPortablePath(p), opts, this.makeCallback(resolve, reject));
      } else {
        this.realFs.rmdir(npath.fromPortablePath(p), this.makeCallback(resolve, reject));
      }
    });
  }
  rmdirSync(p, opts) {
    return this.realFs.rmdirSync(npath.fromPortablePath(p), opts);
  }
  async linkPromise(existingP, newP) {
    return await new Promise((resolve, reject) => {
      this.realFs.link(npath.fromPortablePath(existingP), npath.fromPortablePath(newP), this.makeCallback(resolve, reject));
    });
  }
  linkSync(existingP, newP) {
    return this.realFs.linkSync(npath.fromPortablePath(existingP), npath.fromPortablePath(newP));
  }
  async symlinkPromise(target, p, type) {
    return await new Promise((resolve, reject) => {
      this.realFs.symlink(npath.fromPortablePath(target.replace(/\/+$/, ``)), npath.fromPortablePath(p), type, this.makeCallback(resolve, reject));
    });
  }
  symlinkSync(target, p, type) {
    return this.realFs.symlinkSync(npath.fromPortablePath(target.replace(/\/+$/, ``)), npath.fromPortablePath(p), type);
  }
  async readFilePromise(p, encoding) {
    return await new Promise((resolve, reject) => {
      const fsNativePath = typeof p === `string` ? npath.fromPortablePath(p) : p;
      this.realFs.readFile(fsNativePath, encoding, this.makeCallback(resolve, reject));
    });
  }
  readFileSync(p, encoding) {
    const fsNativePath = typeof p === `string` ? npath.fromPortablePath(p) : p;
    return this.realFs.readFileSync(fsNativePath, encoding);
  }
  async readdirPromise(p, opts) {
    return await new Promise((resolve, reject) => {
      if (opts) {
        if (opts.recursive && process.platform === `win32`) {
          if (opts.withFileTypes) {
            this.realFs.readdir(npath.fromPortablePath(p), opts, this.makeCallback((results) => resolve(results.map(direntToPortable)), reject));
          } else {
            this.realFs.readdir(npath.fromPortablePath(p), opts, this.makeCallback((results) => resolve(results.map(npath.toPortablePath)), reject));
          }
        } else {
          this.realFs.readdir(npath.fromPortablePath(p), opts, this.makeCallback(resolve, reject));
        }
      } else {
        this.realFs.readdir(npath.fromPortablePath(p), this.makeCallback(resolve, reject));
      }
    });
  }
  readdirSync(p, opts) {
    if (opts) {
      if (opts.recursive && process.platform === `win32`) {
        if (opts.withFileTypes) {
          return this.realFs.readdirSync(npath.fromPortablePath(p), opts).map(direntToPortable);
        } else {
          return this.realFs.readdirSync(npath.fromPortablePath(p), opts).map(npath.toPortablePath);
        }
      } else {
        return this.realFs.readdirSync(npath.fromPortablePath(p), opts);
      }
    } else {
      return this.realFs.readdirSync(npath.fromPortablePath(p));
    }
  }
  async readlinkPromise(p) {
    return await new Promise((resolve, reject) => {
      this.realFs.readlink(npath.fromPortablePath(p), this.makeCallback(resolve, reject));
    }).then((path) => {
      return npath.toPortablePath(path);
    });
  }
  readlinkSync(p) {
    return npath.toPortablePath(this.realFs.readlinkSync(npath.fromPortablePath(p)));
  }
  async truncatePromise(p, len) {
    return await new Promise((resolve, reject) => {
      this.realFs.truncate(npath.fromPortablePath(p), len, this.makeCallback(resolve, reject));
    });
  }
  truncateSync(p, len) {
    return this.realFs.truncateSync(npath.fromPortablePath(p), len);
  }
  async ftruncatePromise(fd, len) {
    return await new Promise((resolve, reject) => {
      this.realFs.ftruncate(fd, len, this.makeCallback(resolve, reject));
    });
  }
  ftruncateSync(fd, len) {
    return this.realFs.ftruncateSync(fd, len);
  }
  watch(p, a, b) {
    return this.realFs.watch(
      npath.fromPortablePath(p),
      a,
      b
    );
  }
  watchFile(p, a, b) {
    return this.realFs.watchFile(
      npath.fromPortablePath(p),
      a,
      b
    );
  }
  unwatchFile(p, cb) {
    return this.realFs.unwatchFile(npath.fromPortablePath(p), cb);
  }
  makeCallback(resolve, reject) {
    return (err, result) => {
      if (err) {
        reject(err);
      } else {
        resolve(result);
      }
    };
  }
}

const NUMBER_REGEXP = /^[0-9]+$/;
const VIRTUAL_REGEXP = /^(\/(?:[^/]+\/)*?(?:\$\$virtual|__virtual__))((?:\/((?:[^/]+-)?[a-f0-9]+)(?:\/([^/]+))?)?((?:\/.*)?))$/;
const VALID_COMPONENT = /^([^/]+-)?[a-f0-9]+$/;
class VirtualFS extends ProxiedFS {
  constructor({ baseFs = new NodeFS() } = {}) {
    super(ppath);
    this.baseFs = baseFs;
  }
  static makeVirtualPath(base, component, to) {
    if (ppath.basename(base) !== `__virtual__`)
      throw new Error(`Assertion failed: Virtual folders must be named "__virtual__"`);
    if (!ppath.basename(component).match(VALID_COMPONENT))
      throw new Error(`Assertion failed: Virtual components must be ended by an hexadecimal hash`);
    const target = ppath.relative(ppath.dirname(base), to);
    const segments = target.split(`/`);
    let depth = 0;
    while (depth < segments.length && segments[depth] === `..`)
      depth += 1;
    const finalSegments = segments.slice(depth);
    const fullVirtualPath = ppath.join(base, component, String(depth), ...finalSegments);
    return fullVirtualPath;
  }
  static resolveVirtual(p) {
    const match = p.match(VIRTUAL_REGEXP);
    if (!match || !match[3] && match[5])
      return p;
    const target = ppath.dirname(match[1]);
    if (!match[3] || !match[4])
      return target;
    const isnum = NUMBER_REGEXP.test(match[4]);
    if (!isnum)
      return p;
    const depth = Number(match[4]);
    const backstep = `../`.repeat(depth);
    const subpath = match[5] || `.`;
    return VirtualFS.resolveVirtual(ppath.join(target, backstep, subpath));
  }
  getExtractHint(hints) {
    return this.baseFs.getExtractHint(hints);
  }
  getRealPath() {
    return this.baseFs.getRealPath();
  }
  realpathSync(p) {
    const match = p.match(VIRTUAL_REGEXP);
    if (!match)
      return this.baseFs.realpathSync(p);
    if (!match[5])
      return p;
    const realpath = this.baseFs.realpathSync(this.mapToBase(p));
    return VirtualFS.makeVirtualPath(match[1], match[3], realpath);
  }
  async realpathPromise(p) {
    const match = p.match(VIRTUAL_REGEXP);
    if (!match)
      return await this.baseFs.realpathPromise(p);
    if (!match[5])
      return p;
    const realpath = await this.baseFs.realpathPromise(this.mapToBase(p));
    return VirtualFS.makeVirtualPath(match[1], match[3], realpath);
  }
  mapToBase(p) {
    if (p === ``)
      return p;
    if (this.pathUtils.isAbsolute(p))
      return VirtualFS.resolveVirtual(p);
    const resolvedRoot = VirtualFS.resolveVirtual(this.baseFs.resolve(PortablePath.dot));
    const resolvedP = VirtualFS.resolveVirtual(this.baseFs.resolve(p));
    return ppath.relative(resolvedRoot, resolvedP) || PortablePath.dot;
  }
  mapFromBase(p) {
    return p;
  }
}

const prettyJsonMachine = {
  ["DEFAULT" /* DEFAULT */]: {
    collapsed: false,
    next: {
      [`*`]: "DEFAULT" /* DEFAULT */
    }
  },
  ["TOP_LEVEL" /* TOP_LEVEL */]: {
    collapsed: false,
    next: {
      [`fallbackExclusionList`]: "FALLBACK_EXCLUSION_LIST" /* FALLBACK_EXCLUSION_LIST */,
      [`packageRegistryData`]: "PACKAGE_REGISTRY_DATA" /* PACKAGE_REGISTRY_DATA */,
      [`*`]: "DEFAULT" /* DEFAULT */
    }
  },
  ["FALLBACK_EXCLUSION_LIST" /* FALLBACK_EXCLUSION_LIST */]: {
    collapsed: false,
    next: {
      [`*`]: "FALLBACK_EXCLUSION_ENTRIES" /* FALLBACK_EXCLUSION_ENTRIES */
    }
  },
  ["FALLBACK_EXCLUSION_ENTRIES" /* FALLBACK_EXCLUSION_ENTRIES */]: {
    collapsed: true,
    next: {
      [`*`]: "FALLBACK_EXCLUSION_DATA" /* FALLBACK_EXCLUSION_DATA */
    }
  },
  ["FALLBACK_EXCLUSION_DATA" /* FALLBACK_EXCLUSION_DATA */]: {
    collapsed: true,
    next: {
      [`*`]: "DEFAULT" /* DEFAULT */
    }
  },
  ["PACKAGE_REGISTRY_DATA" /* PACKAGE_REGISTRY_DATA */]: {
    collapsed: false,
    next: {
      [`*`]: "PACKAGE_REGISTRY_ENTRIES" /* PACKAGE_REGISTRY_ENTRIES */
    }
  },
  ["PACKAGE_REGISTRY_ENTRIES" /* PACKAGE_REGISTRY_ENTRIES */]: {
    collapsed: true,
    next: {
      [`*`]: "PACKAGE_STORE_DATA" /* PACKAGE_STORE_DATA */
    }
  },
  ["PACKAGE_STORE_DATA" /* PACKAGE_STORE_DATA */]: {
    collapsed: false,
    next: {
      [`*`]: "PACKAGE_STORE_ENTRIES" /* PACKAGE_STORE_ENTRIES */
    }
  },
  ["PACKAGE_STORE_ENTRIES" /* PACKAGE_STORE_ENTRIES */]: {
    collapsed: true,
    next: {
      [`*`]: "PACKAGE_INFORMATION_DATA" /* PACKAGE_INFORMATION_DATA */
    }
  },
  ["PACKAGE_INFORMATION_DATA" /* PACKAGE_INFORMATION_DATA */]: {
    collapsed: false,
    next: {
      [`packageDependencies`]: "PACKAGE_DEPENDENCIES" /* PACKAGE_DEPENDENCIES */,
      [`*`]: "DEFAULT" /* DEFAULT */
    }
  },
  ["PACKAGE_DEPENDENCIES" /* PACKAGE_DEPENDENCIES */]: {
    collapsed: false,
    next: {
      [`*`]: "PACKAGE_DEPENDENCY" /* PACKAGE_DEPENDENCY */
    }
  },
  ["PACKAGE_DEPENDENCY" /* PACKAGE_DEPENDENCY */]: {
    collapsed: true,
    next: {
      [`*`]: "DEFAULT" /* DEFAULT */
    }
  }
};
function generateCollapsedArray(data, state, indent) {
  let result = ``;
  result += `[`;
  for (let t = 0, T = data.length; t < T; ++t) {
    result += generateNext(String(t), data[t], state, indent).replace(/^ +/g, ``);
    if (t + 1 < T) {
      result += `, `;
    }
  }
  result += `]`;
  return result;
}
function generateExpandedArray(data, state, indent) {
  const nextIndent = `${indent}  `;
  let result = ``;
  result += indent;
  result += `[
`;
  for (let t = 0, T = data.length; t < T; ++t) {
    result += nextIndent + generateNext(String(t), data[t], state, nextIndent).replace(/^ +/, ``);
    if (t + 1 < T)
      result += `,`;
    result += `
`;
  }
  result += indent;
  result += `]`;
  return result;
}
function generateCollapsedObject(data, state, indent) {
  const keys = Object.keys(data);
  let result = ``;
  result += `{`;
  for (let t = 0, T = keys.length, keysPrinted = 0; t < T; ++t) {
    const key = keys[t];
    const value = data[key];
    if (typeof value === `undefined`)
      continue;
    if (keysPrinted !== 0)
      result += `, `;
    result += JSON.stringify(key);
    result += `: `;
    result += generateNext(key, value, state, indent).replace(/^ +/g, ``);
    keysPrinted += 1;
  }
  result += `}`;
  return result;
}
function generateExpandedObject(data, state, indent) {
  const keys = Object.keys(data);
  const nextIndent = `${indent}  `;
  let result = ``;
  result += indent;
  result += `{
`;
  let keysPrinted = 0;
  for (let t = 0, T = keys.length; t < T; ++t) {
    const key = keys[t];
    const value = data[key];
    if (typeof value === `undefined`)
      continue;
    if (keysPrinted !== 0) {
      result += `,`;
      result += `
`;
    }
    result += nextIndent;
    result += JSON.stringify(key);
    result += `: `;
    result += generateNext(key, value, state, nextIndent).replace(/^ +/g, ``);
    keysPrinted += 1;
  }
  if (keysPrinted !== 0)
    result += `
`;
  result += indent;
  result += `}`;
  return result;
}
function generateNext(key, data, state, indent) {
  const { next } = prettyJsonMachine[state];
  const nextState = next[key] || next[`*`];
  return generate(data, nextState, indent);
}
function generate(data, state, indent) {
  const { collapsed } = prettyJsonMachine[state];
  if (Array.isArray(data)) {
    if (collapsed) {
      return generateCollapsedArray(data, state, indent);
    } else {
      return generateExpandedArray(data, state, indent);
    }
  }
  if (typeof data === `object` && data !== null) {
    if (collapsed) {
      return generateCollapsedObject(data, state, indent);
    } else {
      return generateExpandedObject(data, state, indent);
    }
  }
  return JSON.stringify(data);
}
function generatePrettyJson(data) {
  return generate(data, "TOP_LEVEL" /* TOP_LEVEL */, ``);
}

function sortMap(values, mappers) {
  const asArray = Array.from(values);
  if (!Array.isArray(mappers))
    mappers = [mappers];
  const stringified = [];
  for (const mapper of mappers)
    stringified.push(asArray.map((value) => mapper(value)));
  const indices = asArray.map((_, index) => index);
  indices.sort((a, b) => {
    for (const layer of stringified) {
      const comparison = layer[a] < layer[b] ? -1 : layer[a] > layer[b] ? 1 : 0;
      if (comparison !== 0) {
        return comparison;
      }
    }
    return 0;
  });
  return indices.map((index) => {
    return asArray[index];
  });
}
function generateFallbackExclusionList(settings) {
  const fallbackExclusionList = /* @__PURE__ */ new Map();
  const sortedData = sortMap(settings.fallbackExclusionList || [], [
    ({ name, reference }) => name,
    ({ name, reference }) => reference
  ]);
  for (const { name, reference } of sortedData) {
    let references = fallbackExclusionList.get(name);
    if (typeof references === `undefined`)
      fallbackExclusionList.set(name, references = /* @__PURE__ */ new Set());
    references.add(reference);
  }
  return Array.from(fallbackExclusionList).map(([name, references]) => {
    return [name, Array.from(references)];
  });
}
function generateFallbackPoolData(settings) {
  return sortMap(settings.fallbackPool || [], ([name]) => name);
}
function generatePackageRegistryData(settings) {
  const packageRegistryData = [];
  for (const [packageName, packageStore] of sortMap(settings.packageRegistry, ([packageName2]) => packageName2 === null ? `0` : `1${packageName2}`)) {
    const packageStoreData = [];
    packageRegistryData.push([packageName, packageStoreData]);
    for (const [packageReference, { packageLocation, packageDependencies, packagePeers, linkType, discardFromLookup }] of sortMap(packageStore, ([packageReference2]) => packageReference2 === null ? `0` : `1${packageReference2}`)) {
      const normalizedDependencies = [];
      if (packageName !== null && packageReference !== null && !packageDependencies.has(packageName))
        normalizedDependencies.push([packageName, packageReference]);
      for (const [dependencyName, dependencyReference] of sortMap(packageDependencies.entries(), ([dependencyName2]) => dependencyName2))
        normalizedDependencies.push([dependencyName, dependencyReference]);
      const normalizedPeers = packagePeers && packagePeers.size > 0 ? Array.from(packagePeers) : void 0;
      const normalizedDiscardFromLookup = discardFromLookup ? discardFromLookup : void 0;
      packageStoreData.push([packageReference, {
        packageLocation,
        packageDependencies: normalizedDependencies,
        packagePeers: normalizedPeers,
        linkType,
        discardFromLookup: normalizedDiscardFromLookup
      }]);
    }
  }
  return packageRegistryData;
}
function generateSerializedState(settings) {
  return {
    __info: [
      `This file is automatically generated. Do not touch it, or risk`,
      `your modifications being lost.`
    ],
    dependencyTreeRoots: settings.dependencyTreeRoots,
    enableTopLevelFallback: settings.enableTopLevelFallback || false,
    ignorePatternData: settings.ignorePattern || null,
    fallbackExclusionList: generateFallbackExclusionList(settings),
    fallbackPool: generateFallbackPoolData(settings),
    packageRegistryData: generatePackageRegistryData(settings)
  };
}

let hook$1;
var hook_1 = () => {
  if (typeof hook$1 === `undefined`)
    hook$1 = require$$0__default.default.brotliDecompressSync(Buffer.from("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", "base64")).toString();
  return hook$1;
};

function generateLoader(shebang, loader) {
  return [
    shebang ? `${shebang}
` : ``,
    `/* eslint-disable */
`,
    `"use strict";
`,
    `
`,
    loader,
    `
`,
    hook_1()
  ].join(``);
}
function generateJsonString(data) {
  return JSON.stringify(data, null, 2);
}
function generateStringLiteral(value) {
  return `'${value.replace(/\\/g, `\\\\`).replace(/'/g, `\\'`).replace(/\n/g, `\\
`)}'`;
}
function generateInlinedSetup(data) {
  return [
    `const RAW_RUNTIME_STATE =
`,
    `${generateStringLiteral(generatePrettyJson(data))};

`,
    `function $$SETUP_STATE(hydrateRuntimeState, basePath) {
`,
    `  return hydrateRuntimeState(JSON.parse(RAW_RUNTIME_STATE), {basePath: basePath || __dirname});
`,
    `}
`
  ].join(``);
}
function generateSplitSetup() {
  return [
    `function $$SETUP_STATE(hydrateRuntimeState, basePath) {
`,
    `  const fs = require('fs');
`,
    `  const path = require('path');
`,
    `  const pnpDataFilepath = path.resolve(__dirname, ${JSON.stringify(Filename.pnpData)});
`,
    `  return hydrateRuntimeState(JSON.parse(fs.readFileSync(pnpDataFilepath, 'utf8')), {basePath: basePath || __dirname});
`,
    `}
`
  ].join(``);
}
function generateInlinedScript(settings) {
  const data = generateSerializedState(settings);
  const setup = generateInlinedSetup(data);
  const loaderFile = generateLoader(settings.shebang, setup);
  return loaderFile;
}
function generateSplitScript(settings) {
  const data = generateSerializedState(settings);
  const setup = generateSplitSetup();
  const loaderFile = generateLoader(settings.shebang, setup);
  return { dataFile: generateJsonString(data), loaderFile };
}

function hydrateRuntimeState(data, { basePath }) {
  const portablePath = npath.toPortablePath(basePath);
  const absolutePortablePath = ppath.resolve(portablePath);
  const ignorePattern = data.ignorePatternData !== null ? new RegExp(data.ignorePatternData) : null;
  const packageLocatorsByLocations = /* @__PURE__ */ new Map();
  const packageRegistry = new Map(data.packageRegistryData.map(([packageName, packageStoreData]) => {
    return [packageName, new Map(packageStoreData.map(([packageReference, packageInformationData]) => {
      if (packageName === null !== (packageReference === null))
        throw new Error(`Assertion failed: The name and reference should be null, or neither should`);
      const discardFromLookup = packageInformationData.discardFromLookup ?? false;
      const packageLocator = { name: packageName, reference: packageReference };
      const entry = packageLocatorsByLocations.get(packageInformationData.packageLocation);
      if (!entry) {
        packageLocatorsByLocations.set(packageInformationData.packageLocation, { locator: packageLocator, discardFromLookup });
      } else {
        entry.discardFromLookup = entry.discardFromLookup && discardFromLookup;
        if (!discardFromLookup) {
          entry.locator = packageLocator;
        }
      }
      let resolvedPackageLocation = null;
      return [packageReference, {
        packageDependencies: new Map(packageInformationData.packageDependencies),
        packagePeers: new Set(packageInformationData.packagePeers),
        linkType: packageInformationData.linkType,
        discardFromLookup,
        get packageLocation() {
          return resolvedPackageLocation || (resolvedPackageLocation = ppath.join(absolutePortablePath, packageInformationData.packageLocation));
        }
      }];
    }))];
  }));
  const fallbackExclusionList = new Map(data.fallbackExclusionList.map(([packageName, packageReferences]) => {
    return [packageName, new Set(packageReferences)];
  }));
  const fallbackPool = new Map(data.fallbackPool);
  const dependencyTreeRoots = data.dependencyTreeRoots;
  const enableTopLevelFallback = data.enableTopLevelFallback;
  return {
    basePath: portablePath,
    dependencyTreeRoots,
    enableTopLevelFallback,
    fallbackExclusionList,
    fallbackPool,
    ignorePattern,
    packageLocatorsByLocations,
    packageRegistry
  };
}

const ArrayIsArray = Array.isArray;
const JSONStringify = JSON.stringify;
const ObjectGetOwnPropertyNames = Object.getOwnPropertyNames;
const ObjectPrototypeHasOwnProperty = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);
const RegExpPrototypeExec = (obj, string) => RegExp.prototype.exec.call(obj, string);
const RegExpPrototypeSymbolReplace = (obj, ...rest) => RegExp.prototype[Symbol.replace].apply(obj, rest);
const StringPrototypeEndsWith = (str, ...rest) => String.prototype.endsWith.apply(str, rest);
const StringPrototypeIncludes = (str, ...rest) => String.prototype.includes.apply(str, rest);
const StringPrototypeLastIndexOf = (str, ...rest) => String.prototype.lastIndexOf.apply(str, rest);
const StringPrototypeIndexOf = (str, ...rest) => String.prototype.indexOf.apply(str, rest);
const StringPrototypeReplace = (str, ...rest) => String.prototype.replace.apply(str, rest);
const StringPrototypeSlice = (str, ...rest) => String.prototype.slice.apply(str, rest);
const StringPrototypeStartsWith = (str, ...rest) => String.prototype.startsWith.apply(str, rest);
const SafeMap = Map;
const JSONParse = JSON.parse;

function createErrorType(code, messageCreator, errorType) {
  return class extends errorType {
    constructor(...args) {
      super(messageCreator(...args));
      this.code = code;
      this.name = `${errorType.name} [${code}]`;
    }
  };
}
const ERR_PACKAGE_IMPORT_NOT_DEFINED = createErrorType(
  `ERR_PACKAGE_IMPORT_NOT_DEFINED`,
  (specifier, packagePath, base) => {
    return `Package import specifier "${specifier}" is not defined${packagePath ? ` in package ${packagePath}package.json` : ``} imported from ${base}`;
  },
  TypeError
);
const ERR_INVALID_MODULE_SPECIFIER = createErrorType(
  `ERR_INVALID_MODULE_SPECIFIER`,
  (request, reason, base = void 0) => {
    return `Invalid module "${request}" ${reason}${base ? ` imported from ${base}` : ``}`;
  },
  TypeError
);
const ERR_INVALID_PACKAGE_TARGET = createErrorType(
  `ERR_INVALID_PACKAGE_TARGET`,
  (pkgPath, key, target, isImport = false, base = void 0) => {
    const relError = typeof target === `string` && !isImport && target.length && !StringPrototypeStartsWith(target, `./`);
    if (key === `.`) {
      assert__default.default(isImport === false);
      return `Invalid "exports" main target ${JSONStringify(target)} defined in the package config ${pkgPath}package.json${base ? ` imported from ${base}` : ``}${relError ? `; targets must start with "./"` : ``}`;
    }
    return `Invalid "${isImport ? `imports` : `exports`}" target ${JSONStringify(
      target
    )} defined for '${key}' in the package config ${pkgPath}package.json${base ? ` imported from ${base}` : ``}${relError ? `; targets must start with "./"` : ``}`;
  },
  Error
);
const ERR_INVALID_PACKAGE_CONFIG = createErrorType(
  `ERR_INVALID_PACKAGE_CONFIG`,
  (path, base, message) => {
    return `Invalid package config ${path}${base ? ` while importing ${base}` : ``}${message ? `. ${message}` : ``}`;
  },
  Error
);
const ERR_PACKAGE_PATH_NOT_EXPORTED = createErrorType(
  "ERR_PACKAGE_PATH_NOT_EXPORTED",
  (pkgPath, subpath, base = void 0) => {
    if (subpath === ".")
      return `No "exports" main defined in ${pkgPath}package.json${base ? ` imported from ${base}` : ""}`;
    return `Package subpath '${subpath}' is not defined by "exports" in ${pkgPath}package.json${base ? ` imported from ${base}` : ""}`;
  },
  Error
);

function filterOwnProperties(source, keys) {
  const filtered = /* @__PURE__ */ Object.create(null);
  for (let i = 0; i < keys.length; i++) {
    const key = keys[i];
    if (ObjectPrototypeHasOwnProperty(source, key)) {
      filtered[key] = source[key];
    }
  }
  return filtered;
}

const packageJSONCache = new SafeMap();
function getPackageConfig(path, specifier, base, readFileSyncFn) {
  const existing = packageJSONCache.get(path);
  if (existing !== void 0) {
    return existing;
  }
  const source = readFileSyncFn(path);
  if (source === void 0) {
    const packageConfig2 = {
      pjsonPath: path,
      exists: false,
      main: void 0,
      name: void 0,
      type: "none",
      exports: void 0,
      imports: void 0
    };
    packageJSONCache.set(path, packageConfig2);
    return packageConfig2;
  }
  let packageJSON;
  try {
    packageJSON = JSONParse(source);
  } catch (error) {
    throw new ERR_INVALID_PACKAGE_CONFIG(
      path,
      (base ? `"${specifier}" from ` : "") + url.fileURLToPath(base || specifier),
      error.message
    );
  }
  let { imports, main, name, type } = filterOwnProperties(packageJSON, [
    "imports",
    "main",
    "name",
    "type"
  ]);
  const exports = ObjectPrototypeHasOwnProperty(packageJSON, "exports") ? packageJSON.exports : void 0;
  if (typeof imports !== "object" || imports === null) {
    imports = void 0;
  }
  if (typeof main !== "string") {
    main = void 0;
  }
  if (typeof name !== "string") {
    name = void 0;
  }
  if (type !== "module" && type !== "commonjs") {
    type = "none";
  }
  const packageConfig = {
    pjsonPath: path,
    exists: true,
    main,
    name,
    type,
    exports,
    imports
  };
  packageJSONCache.set(path, packageConfig);
  return packageConfig;
}
function getPackageScopeConfig(resolved, readFileSyncFn) {
  let packageJSONUrl = new URL("./package.json", resolved);
  while (true) {
    const packageJSONPath2 = packageJSONUrl.pathname;
    if (StringPrototypeEndsWith(packageJSONPath2, "node_modules/package.json")) {
      break;
    }
    const packageConfig2 = getPackageConfig(
      url.fileURLToPath(packageJSONUrl),
      resolved,
      void 0,
      readFileSyncFn
    );
    if (packageConfig2.exists) {
      return packageConfig2;
    }
    const lastPackageJSONUrl = packageJSONUrl;
    packageJSONUrl = new URL("../package.json", packageJSONUrl);
    if (packageJSONUrl.pathname === lastPackageJSONUrl.pathname) {
      break;
    }
  }
  const packageJSONPath = url.fileURLToPath(packageJSONUrl);
  const packageConfig = {
    pjsonPath: packageJSONPath,
    exists: false,
    main: void 0,
    name: void 0,
    type: "none",
    exports: void 0,
    imports: void 0
  };
  packageJSONCache.set(packageJSONPath, packageConfig);
  return packageConfig;
}

/**
  @license
  Copyright Node.js contributors. All rights reserved.

  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to
  deal in the Software without restriction, including without limitation the
  rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
  sell copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
  IN THE SOFTWARE.
*/
function throwImportNotDefined(specifier, packageJSONUrl, base) {
  throw new ERR_PACKAGE_IMPORT_NOT_DEFINED(
    specifier,
    packageJSONUrl && url.fileURLToPath(new URL(".", packageJSONUrl)),
    url.fileURLToPath(base)
  );
}
function throwInvalidSubpath(subpath, packageJSONUrl, internal, base) {
  const reason = `request is not a valid subpath for the "${internal ? "imports" : "exports"}" resolution of ${url.fileURLToPath(packageJSONUrl)}`;
  throw new ERR_INVALID_MODULE_SPECIFIER(
    subpath,
    reason,
    base && url.fileURLToPath(base)
  );
}
function throwInvalidPackageTarget(subpath, target, packageJSONUrl, internal, base) {
  if (typeof target === "object" && target !== null) {
    target = JSONStringify(target, null, "");
  } else {
    target = `${target}`;
  }
  throw new ERR_INVALID_PACKAGE_TARGET(
    url.fileURLToPath(new URL(".", packageJSONUrl)),
    subpath,
    target,
    internal,
    base && url.fileURLToPath(base)
  );
}
const invalidSegmentRegEx = /(^|\\|\/)((\.|%2e)(\.|%2e)?|(n|%6e|%4e)(o|%6f|%4f)(d|%64|%44)(e|%65|%45)(_|%5f)(m|%6d|%4d)(o|%6f|%4f)(d|%64|%44)(u|%75|%55)(l|%6c|%4c)(e|%65|%45)(s|%73|%53))(\\|\/|$)/i;
const patternRegEx = /\*/g;
function resolvePackageTargetString(target, subpath, match, packageJSONUrl, base, pattern, internal, conditions) {
  if (subpath !== "" && !pattern && target[target.length - 1] !== "/")
    throwInvalidPackageTarget(match, target, packageJSONUrl, internal, base);
  if (!StringPrototypeStartsWith(target, "./")) {
    if (internal && !StringPrototypeStartsWith(target, "../") && !StringPrototypeStartsWith(target, "/")) {
      let isURL = false;
      try {
        new URL(target);
        isURL = true;
      } catch {
      }
      if (!isURL) {
        const exportTarget = pattern ? RegExpPrototypeSymbolReplace(patternRegEx, target, () => subpath) : target + subpath;
        return exportTarget;
      }
    }
    throwInvalidPackageTarget(match, target, packageJSONUrl, internal, base);
  }
  if (RegExpPrototypeExec(
    invalidSegmentRegEx,
    StringPrototypeSlice(target, 2)
  ) !== null)
    throwInvalidPackageTarget(match, target, packageJSONUrl, internal, base);
  const resolved = new URL(target, packageJSONUrl);
  const resolvedPath = resolved.pathname;
  const packagePath = new URL(".", packageJSONUrl).pathname;
  if (!StringPrototypeStartsWith(resolvedPath, packagePath))
    throwInvalidPackageTarget(match, target, packageJSONUrl, internal, base);
  if (subpath === "")
    return resolved;
  if (RegExpPrototypeExec(invalidSegmentRegEx, subpath) !== null) {
    const request = pattern ? StringPrototypeReplace(match, "*", () => subpath) : match + subpath;
    throwInvalidSubpath(request, packageJSONUrl, internal, base);
  }
  if (pattern) {
    return new URL(
      RegExpPrototypeSymbolReplace(patternRegEx, resolved.href, () => subpath)
    );
  }
  return new URL(subpath, resolved);
}
function isArrayIndex(key) {
  const keyNum = +key;
  if (`${keyNum}` !== key)
    return false;
  return keyNum >= 0 && keyNum < 4294967295;
}
function resolvePackageTarget(packageJSONUrl, target, subpath, packageSubpath, base, pattern, internal, conditions) {
  if (typeof target === "string") {
    return resolvePackageTargetString(
      target,
      subpath,
      packageSubpath,
      packageJSONUrl,
      base,
      pattern,
      internal);
  } else if (ArrayIsArray(target)) {
    if (target.length === 0) {
      return null;
    }
    let lastException;
    for (let i = 0; i < target.length; i++) {
      const targetItem = target[i];
      let resolveResult;
      try {
        resolveResult = resolvePackageTarget(
          packageJSONUrl,
          targetItem,
          subpath,
          packageSubpath,
          base,
          pattern,
          internal,
          conditions
        );
      } catch (e) {
        lastException = e;
        if (e.code === "ERR_INVALID_PACKAGE_TARGET") {
          continue;
        }
        throw e;
      }
      if (resolveResult === void 0) {
        continue;
      }
      if (resolveResult === null) {
        lastException = null;
        continue;
      }
      return resolveResult;
    }
    if (lastException === void 0 || lastException === null)
      return lastException;
    throw lastException;
  } else if (typeof target === "object" && target !== null) {
    const keys = ObjectGetOwnPropertyNames(target);
    for (let i = 0; i < keys.length; i++) {
      const key = keys[i];
      if (isArrayIndex(key)) {
        throw new ERR_INVALID_PACKAGE_CONFIG(
          url.fileURLToPath(packageJSONUrl),
          base,
          '"exports" cannot contain numeric property keys.'
        );
      }
    }
    for (let i = 0; i < keys.length; i++) {
      const key = keys[i];
      if (key === "default" || conditions.has(key)) {
        const conditionalTarget = target[key];
        const resolveResult = resolvePackageTarget(
          packageJSONUrl,
          conditionalTarget,
          subpath,
          packageSubpath,
          base,
          pattern,
          internal,
          conditions
        );
        if (resolveResult === void 0)
          continue;
        return resolveResult;
      }
    }
    return void 0;
  } else if (target === null) {
    return null;
  }
  throwInvalidPackageTarget(
    packageSubpath,
    target,
    packageJSONUrl,
    internal,
    base
  );
}
function patternKeyCompare(a, b) {
  const aPatternIndex = StringPrototypeIndexOf(a, "*");
  const bPatternIndex = StringPrototypeIndexOf(b, "*");
  const baseLenA = aPatternIndex === -1 ? a.length : aPatternIndex + 1;
  const baseLenB = bPatternIndex === -1 ? b.length : bPatternIndex + 1;
  if (baseLenA > baseLenB)
    return -1;
  if (baseLenB > baseLenA)
    return 1;
  if (aPatternIndex === -1)
    return 1;
  if (bPatternIndex === -1)
    return -1;
  if (a.length > b.length)
    return -1;
  if (b.length > a.length)
    return 1;
  return 0;
}
function isConditionalExportsMainSugar(exports, packageJSONUrl, base) {
  if (typeof exports === "string" || ArrayIsArray(exports))
    return true;
  if (typeof exports !== "object" || exports === null)
    return false;
  const keys = ObjectGetOwnPropertyNames(exports);
  let isConditionalSugar = false;
  let i = 0;
  for (let j = 0; j < keys.length; j++) {
    const key = keys[j];
    const curIsConditionalSugar = key === "" || key[0] !== ".";
    if (i++ === 0) {
      isConditionalSugar = curIsConditionalSugar;
    } else if (isConditionalSugar !== curIsConditionalSugar) {
      throw new ERR_INVALID_PACKAGE_CONFIG(
        url.fileURLToPath(packageJSONUrl),
        base,
        `"exports" cannot contain some keys starting with '.' and some not. The exports object must either be an object of package subpath keys or an object of main entry condition name keys only.`
      );
    }
  }
  return isConditionalSugar;
}
function throwExportsNotFound(subpath, packageJSONUrl, base) {
  throw new ERR_PACKAGE_PATH_NOT_EXPORTED(
    url.fileURLToPath(new URL(".", packageJSONUrl)),
    subpath,
    base && url.fileURLToPath(base)
  );
}
const emittedPackageWarnings = /* @__PURE__ */ new Set();
function emitTrailingSlashPatternDeprecation(match, pjsonUrl, base) {
  const pjsonPath = url.fileURLToPath(pjsonUrl);
  if (emittedPackageWarnings.has(pjsonPath + "|" + match))
    return;
  emittedPackageWarnings.add(pjsonPath + "|" + match);
  process.emitWarning(
    `Use of deprecated trailing slash pattern mapping "${match}" in the "exports" field module resolution of the package at ${pjsonPath}${base ? ` imported from ${url.fileURLToPath(base)}` : ""}. Mapping specifiers ending in "/" is no longer supported.`,
    "DeprecationWarning",
    "DEP0155"
  );
}
function packageExportsResolve({
  packageJSONUrl,
  packageSubpath,
  exports,
  base,
  conditions
}) {
  if (isConditionalExportsMainSugar(exports, packageJSONUrl, base))
    exports = { ".": exports };
  if (ObjectPrototypeHasOwnProperty(exports, packageSubpath) && !StringPrototypeIncludes(packageSubpath, "*") && !StringPrototypeEndsWith(packageSubpath, "/")) {
    const target = exports[packageSubpath];
    const resolveResult = resolvePackageTarget(
      packageJSONUrl,
      target,
      "",
      packageSubpath,
      base,
      false,
      false,
      conditions
    );
    if (resolveResult == null) {
      throwExportsNotFound(packageSubpath, packageJSONUrl, base);
    }
    return resolveResult;
  }
  let bestMatch = "";
  let bestMatchSubpath;
  const keys = ObjectGetOwnPropertyNames(exports);
  for (let i = 0; i < keys.length; i++) {
    const key = keys[i];
    const patternIndex = StringPrototypeIndexOf(key, "*");
    if (patternIndex !== -1 && StringPrototypeStartsWith(
      packageSubpath,
      StringPrototypeSlice(key, 0, patternIndex)
    )) {
      if (StringPrototypeEndsWith(packageSubpath, "/"))
        emitTrailingSlashPatternDeprecation(
          packageSubpath,
          packageJSONUrl,
          base
        );
      const patternTrailer = StringPrototypeSlice(key, patternIndex + 1);
      if (packageSubpath.length >= key.length && StringPrototypeEndsWith(packageSubpath, patternTrailer) && patternKeyCompare(bestMatch, key) === 1 && StringPrototypeLastIndexOf(key, "*") === patternIndex) {
        bestMatch = key;
        bestMatchSubpath = StringPrototypeSlice(
          packageSubpath,
          patternIndex,
          packageSubpath.length - patternTrailer.length
        );
      }
    }
  }
  if (bestMatch) {
    const target = exports[bestMatch];
    const resolveResult = resolvePackageTarget(
      packageJSONUrl,
      target,
      bestMatchSubpath,
      bestMatch,
      base,
      true,
      false,
      conditions
    );
    if (resolveResult == null) {
      throwExportsNotFound(packageSubpath, packageJSONUrl, base);
    }
    return resolveResult;
  }
  throwExportsNotFound(packageSubpath, packageJSONUrl, base);
}
function packageImportsResolve({ name, base, conditions, readFileSyncFn }) {
  if (name === "#" || StringPrototypeStartsWith(name, "#/") || StringPrototypeEndsWith(name, "/")) {
    const reason = "is not a valid internal imports specifier name";
    throw new ERR_INVALID_MODULE_SPECIFIER(name, reason, url.fileURLToPath(base));
  }
  let packageJSONUrl;
  const packageConfig = getPackageScopeConfig(base, readFileSyncFn);
  if (packageConfig.exists) {
    packageJSONUrl = url.pathToFileURL(packageConfig.pjsonPath);
    const imports = packageConfig.imports;
    if (imports) {
      if (ObjectPrototypeHasOwnProperty(imports, name) && !StringPrototypeIncludes(name, "*")) {
        const resolveResult = resolvePackageTarget(
          packageJSONUrl,
          imports[name],
          "",
          name,
          base,
          false,
          true,
          conditions
        );
        if (resolveResult != null) {
          return resolveResult;
        }
      } else {
        let bestMatch = "";
        let bestMatchSubpath;
        const keys = ObjectGetOwnPropertyNames(imports);
        for (let i = 0; i < keys.length; i++) {
          const key = keys[i];
          const patternIndex = StringPrototypeIndexOf(key, "*");
          if (patternIndex !== -1 && StringPrototypeStartsWith(
            name,
            StringPrototypeSlice(key, 0, patternIndex)
          )) {
            const patternTrailer = StringPrototypeSlice(key, patternIndex + 1);
            if (name.length >= key.length && StringPrototypeEndsWith(name, patternTrailer) && patternKeyCompare(bestMatch, key) === 1 && StringPrototypeLastIndexOf(key, "*") === patternIndex) {
              bestMatch = key;
              bestMatchSubpath = StringPrototypeSlice(
                name,
                patternIndex,
                name.length - patternTrailer.length
              );
            }
          }
        }
        if (bestMatch) {
          const target = imports[bestMatch];
          const resolveResult = resolvePackageTarget(
            packageJSONUrl,
            target,
            bestMatchSubpath,
            bestMatch,
            base,
            true,
            true,
            conditions
          );
          if (resolveResult != null) {
            return resolveResult;
          }
        }
      }
    }
  }
  throwImportNotDefined(name, packageJSONUrl, base);
}

var ErrorCode = /* @__PURE__ */ ((ErrorCode2) => {
  ErrorCode2["API_ERROR"] = `API_ERROR`;
  ErrorCode2["BUILTIN_NODE_RESOLUTION_FAILED"] = `BUILTIN_NODE_RESOLUTION_FAILED`;
  ErrorCode2["EXPORTS_RESOLUTION_FAILED"] = `EXPORTS_RESOLUTION_FAILED`;
  ErrorCode2["MISSING_DEPENDENCY"] = `MISSING_DEPENDENCY`;
  ErrorCode2["MISSING_PEER_DEPENDENCY"] = `MISSING_PEER_DEPENDENCY`;
  ErrorCode2["QUALIFIED_PATH_RESOLUTION_FAILED"] = `QUALIFIED_PATH_RESOLUTION_FAILED`;
  ErrorCode2["INTERNAL"] = `INTERNAL`;
  ErrorCode2["UNDECLARED_DEPENDENCY"] = `UNDECLARED_DEPENDENCY`;
  ErrorCode2["UNSUPPORTED"] = `UNSUPPORTED`;
  return ErrorCode2;
})(ErrorCode || {});
const MODULE_NOT_FOUND_ERRORS = /* @__PURE__ */ new Set([
  "BUILTIN_NODE_RESOLUTION_FAILED" /* BUILTIN_NODE_RESOLUTION_FAILED */,
  "MISSING_DEPENDENCY" /* MISSING_DEPENDENCY */,
  "MISSING_PEER_DEPENDENCY" /* MISSING_PEER_DEPENDENCY */,
  "QUALIFIED_PATH_RESOLUTION_FAILED" /* QUALIFIED_PATH_RESOLUTION_FAILED */,
  "UNDECLARED_DEPENDENCY" /* UNDECLARED_DEPENDENCY */
]);
function makeError(pnpCode, message, data = {}, code) {
  code ??= MODULE_NOT_FOUND_ERRORS.has(pnpCode) ? `MODULE_NOT_FOUND` : pnpCode;
  const propertySpec = {
    configurable: true,
    writable: true,
    enumerable: false
  };
  return Object.defineProperties(new Error(message), {
    code: {
      ...propertySpec,
      value: code
    },
    pnpCode: {
      ...propertySpec,
      value: pnpCode
    },
    data: {
      ...propertySpec,
      value: data
    }
  });
}
function getPathForDisplay(p) {
  return npath.normalize(npath.fromPortablePath(p));
}

const flagSymbol = Symbol('arg flag');

class ArgError extends Error {
	constructor(msg, code) {
		super(msg);
		this.name = 'ArgError';
		this.code = code;

		Object.setPrototypeOf(this, ArgError.prototype);
	}
}

function arg(
	opts,
	{
		argv = process.argv.slice(2),
		permissive = false,
		stopAtPositional = false
	} = {}
) {
	if (!opts) {
		throw new ArgError(
			'argument specification object is required',
			'ARG_CONFIG_NO_SPEC'
		);
	}

	const result = { _: [] };

	const aliases = {};
	const handlers = {};

	for (const key of Object.keys(opts)) {
		if (!key) {
			throw new ArgError(
				'argument key cannot be an empty string',
				'ARG_CONFIG_EMPTY_KEY'
			);
		}

		if (key[0] !== '-') {
			throw new ArgError(
				`argument key must start with '-' but found: '${key}'`,
				'ARG_CONFIG_NONOPT_KEY'
			);
		}

		if (key.length === 1) {
			throw new ArgError(
				`argument key must have a name; singular '-' keys are not allowed: ${key}`,
				'ARG_CONFIG_NONAME_KEY'
			);
		}

		if (typeof opts[key] === 'string') {
			aliases[key] = opts[key];
			continue;
		}

		let type = opts[key];
		let isFlag = false;

		if (
			Array.isArray(type) &&
			type.length === 1 &&
			typeof type[0] === 'function'
		) {
			const [fn] = type;
			type = (value, name, prev = []) => {
				prev.push(fn(value, name, prev[prev.length - 1]));
				return prev;
			};
			isFlag = fn === Boolean || fn[flagSymbol] === true;
		} else if (typeof type === 'function') {
			isFlag = type === Boolean || type[flagSymbol] === true;
		} else {
			throw new ArgError(
				`type missing or not a function or valid array type: ${key}`,
				'ARG_CONFIG_VAD_TYPE'
			);
		}

		if (key[1] !== '-' && key.length > 2) {
			throw new ArgError(
				`short argument keys (with a single hyphen) must have only one character: ${key}`,
				'ARG_CONFIG_SHORTOPT_TOOLONG'
			);
		}

		handlers[key] = [type, isFlag];
	}

	for (let i = 0, len = argv.length; i < len; i++) {
		const wholeArg = argv[i];

		if (stopAtPositional && result._.length > 0) {
			result._ = result._.concat(argv.slice(i));
			break;
		}

		if (wholeArg === '--') {
			result._ = result._.concat(argv.slice(i + 1));
			break;
		}

		if (wholeArg.length > 1 && wholeArg[0] === '-') {
			/* eslint-disable operator-linebreak */
			const separatedArguments =
				wholeArg[1] === '-' || wholeArg.length === 2
					? [wholeArg]
					: wholeArg
							.slice(1)
							.split('')
							.map((a) => `-${a}`);
			/* eslint-enable operator-linebreak */

			for (let j = 0; j < separatedArguments.length; j++) {
				const arg = separatedArguments[j];
				const [originalArgName, argStr] =
					arg[1] === '-' ? arg.split(/=(.*)/, 2) : [arg, undefined];

				let argName = originalArgName;
				while (argName in aliases) {
					argName = aliases[argName];
				}

				if (!(argName in handlers)) {
					if (permissive) {
						result._.push(arg);
						continue;
					} else {
						throw new ArgError(
							`unknown or unexpected option: ${originalArgName}`,
							'ARG_UNKNOWN_OPTION'
						);
					}
				}

				const [type, isFlag] = handlers[argName];

				if (!isFlag && j + 1 < separatedArguments.length) {
					throw new ArgError(
						`option requires argument (but was followed by another short argument): ${originalArgName}`,
						'ARG_MISSING_REQUIRED_SHORTARG'
					);
				}

				if (isFlag) {
					result[argName] = type(true, argName, result[argName]);
				} else if (argStr === undefined) {
					if (
						argv.length < i + 2 ||
						(argv[i + 1].length > 1 &&
							argv[i + 1][0] === '-' &&
							!(
								argv[i + 1].match(/^-?\d*(\.(?=\d))?\d*$/) &&
								(type === Number ||
									// eslint-disable-next-line no-undef
									(typeof BigInt !== 'undefined' && type === BigInt))
							))
					) {
						const extended =
							originalArgName === argName ? '' : ` (alias for ${argName})`;
						throw new ArgError(
							`option requires argument: ${originalArgName}${extended}`,
							'ARG_MISSING_REQUIRED_LONGARG'
						);
					}

					result[argName] = type(argv[i + 1], argName, result[argName]);
					++i;
				} else {
					result[argName] = type(argStr, argName, result[argName]);
				}
			}
		} else {
			result._.push(wholeArg);
		}
	}

	return result;
}

arg.flag = (fn) => {
	fn[flagSymbol] = true;
	return fn;
};

// Utility types
arg.COUNT = arg.flag((v, name, existingCount) => (existingCount || 0) + 1);

// Expose error class
arg.ArgError = ArgError;

var arg_1 = arg;

/**
  @license
  The MIT License (MIT)

  Copyright (c) 2014 Blake Embrey (hello@blakeembrey.com)

  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
  THE SOFTWARE.
*/
function getOptionValue(opt) {
  parseOptions();
  return options[opt];
}
let options;
function parseOptions() {
  if (!options) {
    options = {
      "--conditions": [],
      ...parseArgv(getNodeOptionsEnvArgv()),
      ...parseArgv(process.execArgv)
    };
  }
}
function parseArgv(argv) {
  return arg_1(
    {
      "--conditions": [String],
      "-C": "--conditions"
    },
    {
      argv,
      permissive: true
    }
  );
}
function getNodeOptionsEnvArgv() {
  const errors = [];
  const envArgv = ParseNodeOptionsEnvVar(process.env.NODE_OPTIONS || "", errors);
  if (errors.length !== 0) ;
  return envArgv;
}
function ParseNodeOptionsEnvVar(node_options, errors) {
  const env_argv = [];
  let is_in_string = false;
  let will_start_new_arg = true;
  for (let index = 0; index < node_options.length; ++index) {
    let c = node_options[index];
    if (c === "\\" && is_in_string) {
      if (index + 1 === node_options.length) {
        errors.push("invalid value for NODE_OPTIONS (invalid escape)\n");
        return env_argv;
      } else {
        c = node_options[++index];
      }
    } else if (c === " " && !is_in_string) {
      will_start_new_arg = true;
      continue;
    } else if (c === '"') {
      is_in_string = !is_in_string;
      continue;
    }
    if (will_start_new_arg) {
      env_argv.push(c);
      will_start_new_arg = false;
    } else {
      env_argv[env_argv.length - 1] += c;
    }
  }
  if (is_in_string) {
    errors.push("invalid value for NODE_OPTIONS (unterminated string)\n");
  }
  return env_argv;
}

const [major, minor] = process.versions.node.split(`.`).map((value) => parseInt(value, 10));
const WATCH_MODE_MESSAGE_USES_ARRAYS = major > 19 || major === 19 && minor >= 2 || major === 18 && minor >= 13;

function reportRequiredFilesToWatchMode(files) {
  if (process.env.WATCH_REPORT_DEPENDENCIES && process.send) {
    files = files.map((filename) => npath.fromPortablePath(VirtualFS.resolveVirtual(npath.toPortablePath(filename))));
    if (WATCH_MODE_MESSAGE_USES_ARRAYS) {
      process.send({ "watch:require": files });
    } else {
      for (const filename of files) {
        process.send({ "watch:require": filename });
      }
    }
  }
}

function makeApi(runtimeState, opts) {
  const alwaysWarnOnFallback = Number(process.env.PNP_ALWAYS_WARN_ON_FALLBACK) > 0;
  const debugLevel = Number(process.env.PNP_DEBUG_LEVEL);
  const pathRegExp = /^(?![a-zA-Z]:[\\/]|\\\\|\.{0,2}(?:\/|$))((?:node:)?(?:@[^/]+\/)?[^/]+)\/*(.*|)$/;
  const isStrictRegExp = /^(\/|\.{1,2}(\/|$))/;
  const isDirRegExp = /\/$/;
  const isRelativeRegexp = /^\.{0,2}\//;
  const topLevelLocator = { name: null, reference: null };
  const fallbackLocators = [];
  const emittedWarnings = /* @__PURE__ */ new Set();
  if (runtimeState.enableTopLevelFallback === true)
    fallbackLocators.push(topLevelLocator);
  if (opts.compatibilityMode !== false) {
    for (const name of [`react-scripts`, `gatsby`]) {
      const packageStore = runtimeState.packageRegistry.get(name);
      if (packageStore) {
        for (const reference of packageStore.keys()) {
          if (reference === null) {
            throw new Error(`Assertion failed: This reference shouldn't be null`);
          } else {
            fallbackLocators.push({ name, reference });
          }
        }
      }
    }
  }
  const {
    ignorePattern,
    packageRegistry,
    packageLocatorsByLocations
  } = runtimeState;
  function makeLogEntry(name, args) {
    return {
      fn: name,
      args,
      error: null,
      result: null
    };
  }
  function trace(entry) {
    const colors = process.stderr?.hasColors?.() ?? process.stdout.isTTY;
    const c = (n, str) => `\x1B[${n}m${str}\x1B[0m`;
    const error = entry.error;
    if (error)
      console.error(c(`31;1`, `\u2716 ${entry.error?.message.replace(/\n.*/s, ``)}`));
    else
      console.error(c(`33;1`, `\u203C Resolution`));
    if (entry.args.length > 0)
      console.error();
    for (const arg of entry.args)
      console.error(`  ${c(`37;1`, `In \u2190`)} ${nodeUtils.inspect(arg, { colors, compact: true })}`);
    if (entry.result) {
      console.error();
      console.error(`  ${c(`37;1`, `Out \u2192`)} ${nodeUtils.inspect(entry.result, { colors, compact: true })}`);
    }
    const stack = new Error().stack.match(/(?<=^ +)at.*/gm)?.slice(2) ?? [];
    if (stack.length > 0) {
      console.error();
      for (const line of stack) {
        console.error(`  ${c(`38;5;244`, line)}`);
      }
    }
    console.error();
  }
  function maybeLog(name, fn) {
    if (opts.allowDebug === false)
      return fn;
    if (Number.isFinite(debugLevel)) {
      if (debugLevel >= 2) {
        return (...args) => {
          const logEntry = makeLogEntry(name, args);
          try {
            return logEntry.result = fn(...args);
          } catch (error) {
            throw logEntry.error = error;
          } finally {
            trace(logEntry);
          }
        };
      } else if (debugLevel >= 1) {
        return (...args) => {
          try {
            return fn(...args);
          } catch (error) {
            const logEntry = makeLogEntry(name, args);
            logEntry.error = error;
            trace(logEntry);
            throw error;
          }
        };
      }
    }
    return fn;
  }
  function getPackageInformationSafe(packageLocator) {
    const packageInformation = getPackageInformation(packageLocator);
    if (!packageInformation) {
      throw makeError(
        ErrorCode.INTERNAL,
        `Couldn't find a matching entry in the dependency tree for the specified parent (this is probably an internal error)`
      );
    }
    return packageInformation;
  }
  function isDependencyTreeRoot(packageLocator) {
    if (packageLocator.name === null)
      return true;
    for (const dependencyTreeRoot of runtimeState.dependencyTreeRoots)
      if (dependencyTreeRoot.name === packageLocator.name && dependencyTreeRoot.reference === packageLocator.reference)
        return true;
    return false;
  }
  const defaultExportsConditions = /* @__PURE__ */ new Set([
    `node`,
    `require`,
    ...getOptionValue(`--conditions`)
  ]);
  function applyNodeExportsResolution(unqualifiedPath, conditions = defaultExportsConditions, issuer) {
    const locator = findPackageLocator(ppath.join(unqualifiedPath, `internal.js`), {
      resolveIgnored: true,
      includeDiscardFromLookup: true
    });
    if (locator === null) {
      throw makeError(
        ErrorCode.INTERNAL,
        `The locator that owns the "${unqualifiedPath}" path can't be found inside the dependency tree (this is probably an internal error)`
      );
    }
    const { packageLocation } = getPackageInformationSafe(locator);
    const manifestPath = ppath.join(packageLocation, Filename.manifest);
    if (!opts.fakeFs.existsSync(manifestPath))
      return null;
    const pkgJson = JSON.parse(opts.fakeFs.readFileSync(manifestPath, `utf8`));
    if (pkgJson.exports == null)
      return null;
    let subpath = ppath.contains(packageLocation, unqualifiedPath);
    if (subpath === null) {
      throw makeError(
        ErrorCode.INTERNAL,
        `unqualifiedPath doesn't contain the packageLocation (this is probably an internal error)`
      );
    }
    if (subpath !== `.` && !isRelativeRegexp.test(subpath))
      subpath = `./${subpath}`;
    try {
      const resolvedExport = packageExportsResolve({
        packageJSONUrl: url.pathToFileURL(npath.fromPortablePath(manifestPath)),
        packageSubpath: subpath,
        exports: pkgJson.exports,
        base: issuer ? url.pathToFileURL(npath.fromPortablePath(issuer)) : null,
        conditions
      });
      return npath.toPortablePath(url.fileURLToPath(resolvedExport));
    } catch (error) {
      throw makeError(
        ErrorCode.EXPORTS_RESOLUTION_FAILED,
        error.message,
        { unqualifiedPath: getPathForDisplay(unqualifiedPath), locator, pkgJson, subpath: getPathForDisplay(subpath), conditions },
        error.code
      );
    }
  }
  function applyNodeExtensionResolution(unqualifiedPath, candidates, { extensions }) {
    let stat;
    try {
      candidates.push(unqualifiedPath);
      stat = opts.fakeFs.statSync(unqualifiedPath);
    } catch (error) {
    }
    if (stat && !stat.isDirectory())
      return opts.fakeFs.realpathSync(unqualifiedPath);
    if (stat && stat.isDirectory()) {
      let pkgJson;
      try {
        pkgJson = JSON.parse(opts.fakeFs.readFileSync(ppath.join(unqualifiedPath, Filename.manifest), `utf8`));
      } catch (error) {
      }
      let nextUnqualifiedPath;
      if (pkgJson && pkgJson.main)
        nextUnqualifiedPath = ppath.resolve(unqualifiedPath, pkgJson.main);
      if (nextUnqualifiedPath && nextUnqualifiedPath !== unqualifiedPath) {
        const resolution = applyNodeExtensionResolution(nextUnqualifiedPath, candidates, { extensions });
        if (resolution !== null) {
          return resolution;
        }
      }
    }
    for (let i = 0, length = extensions.length; i < length; i++) {
      const candidateFile = `${unqualifiedPath}${extensions[i]}`;
      candidates.push(candidateFile);
      if (opts.fakeFs.existsSync(candidateFile)) {
        return candidateFile;
      }
    }
    if (stat && stat.isDirectory()) {
      for (let i = 0, length = extensions.length; i < length; i++) {
        const candidateFile = ppath.format({ dir: unqualifiedPath, name: `index`, ext: extensions[i] });
        candidates.push(candidateFile);
        if (opts.fakeFs.existsSync(candidateFile)) {
          return candidateFile;
        }
      }
    }
    return null;
  }
  function makeFakeModule(path) {
    const fakeModule = new module$1.Module(path, null);
    fakeModule.filename = path;
    fakeModule.paths = module$1.Module._nodeModulePaths(path);
    return fakeModule;
  }
  function callNativeResolution(request, issuer) {
    if (issuer.endsWith(`/`))
      issuer = ppath.join(issuer, `internal.js`);
    return module$1.Module._resolveFilename(npath.fromPortablePath(request), makeFakeModule(npath.fromPortablePath(issuer)), false, { plugnplay: false });
  }
  function isPathIgnored(path) {
    if (ignorePattern === null)
      return false;
    const subPath = ppath.contains(runtimeState.basePath, path);
    if (subPath === null)
      return false;
    if (ignorePattern.test(subPath.replace(/\/$/, ``))) {
      return true;
    } else {
      return false;
    }
  }
  const VERSIONS = { std: 3, resolveVirtual: 1, getAllLocators: 1 };
  const topLevel = topLevelLocator;
  function getPackageInformation({ name, reference }) {
    const packageInformationStore = packageRegistry.get(name);
    if (!packageInformationStore)
      return null;
    const packageInformation = packageInformationStore.get(reference);
    if (!packageInformation)
      return null;
    return packageInformation;
  }
  function findPackageDependents({ name, reference }) {
    const dependents = [];
    for (const [dependentName, packageInformationStore] of packageRegistry) {
      if (dependentName === null)
        continue;
      for (const [dependentReference, packageInformation] of packageInformationStore) {
        if (dependentReference === null)
          continue;
        const dependencyReference = packageInformation.packageDependencies.get(name);
        if (dependencyReference !== reference)
          continue;
        if (dependentName === name && dependentReference === reference)
          continue;
        dependents.push({
          name: dependentName,
          reference: dependentReference
        });
      }
    }
    return dependents;
  }
  function findBrokenPeerDependencies(dependency, initialPackage) {
    const brokenPackages = /* @__PURE__ */ new Map();
    const alreadyVisited = /* @__PURE__ */ new Set();
    const traversal = (currentPackage) => {
      const identifier = JSON.stringify(currentPackage.name);
      if (alreadyVisited.has(identifier))
        return;
      alreadyVisited.add(identifier);
      const dependents = findPackageDependents(currentPackage);
      for (const dependent of dependents) {
        const dependentInformation = getPackageInformationSafe(dependent);
        if (dependentInformation.packagePeers.has(dependency)) {
          traversal(dependent);
        } else {
          let brokenSet = brokenPackages.get(dependent.name);
          if (typeof brokenSet === `undefined`)
            brokenPackages.set(dependent.name, brokenSet = /* @__PURE__ */ new Set());
          brokenSet.add(dependent.reference);
        }
      }
    };
    traversal(initialPackage);
    const brokenList = [];
    for (const name of [...brokenPackages.keys()].sort())
      for (const reference of [...brokenPackages.get(name)].sort())
        brokenList.push({ name, reference });
    return brokenList;
  }
  function findPackageLocator(location, { resolveIgnored = false, includeDiscardFromLookup = false } = {}) {
    if (isPathIgnored(location) && !resolveIgnored)
      return null;
    let relativeLocation = ppath.relative(runtimeState.basePath, location);
    if (!relativeLocation.match(isStrictRegExp))
      relativeLocation = `./${relativeLocation}`;
    if (!relativeLocation.endsWith(`/`))
      relativeLocation = `${relativeLocation}/`;
    do {
      const entry = packageLocatorsByLocations.get(relativeLocation);
      if (typeof entry === `undefined` || entry.discardFromLookup && !includeDiscardFromLookup) {
        relativeLocation = relativeLocation.substring(0, relativeLocation.lastIndexOf(`/`, relativeLocation.length - 2) + 1);
        continue;
      }
      return entry.locator;
    } while (relativeLocation !== ``);
    return null;
  }
  function tryReadFile(filePath) {
    try {
      return opts.fakeFs.readFileSync(npath.toPortablePath(filePath), `utf8`);
    } catch (err) {
      if (err.code === `ENOENT`)
        return void 0;
      throw err;
    }
  }
  function resolveToUnqualified(request, issuer, { considerBuiltins = true } = {}) {
    if (request.startsWith(`#`))
      throw new Error(`resolveToUnqualified can not handle private import mappings`);
    if (request === `pnpapi`)
      return npath.toPortablePath(opts.pnpapiResolution);
    if (considerBuiltins && module$1.isBuiltin(request))
      return null;
    const requestForDisplay = getPathForDisplay(request);
    const issuerForDisplay = issuer && getPathForDisplay(issuer);
    if (issuer && isPathIgnored(issuer)) {
      if (!ppath.isAbsolute(request) || findPackageLocator(request) === null) {
        const result = callNativeResolution(request, issuer);
        if (result === false) {
          throw makeError(
            ErrorCode.BUILTIN_NODE_RESOLUTION_FAILED,
            `The builtin node resolution algorithm was unable to resolve the requested module (it didn't go through the pnp resolver because the issuer was explicitely ignored by the regexp)

Require request: "${requestForDisplay}"
Required by: ${issuerForDisplay}
`,
            { request: requestForDisplay, issuer: issuerForDisplay }
          );
        }
        return npath.toPortablePath(result);
      }
    }
    let unqualifiedPath;
    const dependencyNameMatch = request.match(pathRegExp);
    if (!dependencyNameMatch) {
      if (ppath.isAbsolute(request)) {
        unqualifiedPath = ppath.normalize(request);
      } else {
        if (!issuer) {
          throw makeError(
            ErrorCode.API_ERROR,
            `The resolveToUnqualified function must be called with a valid issuer when the path isn't a builtin nor absolute`,
            { request: requestForDisplay, issuer: issuerForDisplay }
          );
        }
        const absoluteIssuer = ppath.resolve(issuer);
        if (issuer.match(isDirRegExp)) {
          unqualifiedPath = ppath.normalize(ppath.join(absoluteIssuer, request));
        } else {
          unqualifiedPath = ppath.normalize(ppath.join(ppath.dirname(absoluteIssuer), request));
        }
      }
    } else {
      if (!issuer) {
        throw makeError(
          ErrorCode.API_ERROR,
          `The resolveToUnqualified function must be called with a valid issuer when the path isn't a builtin nor absolute`,
          { request: requestForDisplay, issuer: issuerForDisplay }
        );
      }
      const [, dependencyName, subPath] = dependencyNameMatch;
      const issuerLocator = findPackageLocator(issuer);
      if (!issuerLocator) {
        const result = callNativeResolution(request, issuer);
        if (result === false) {
          throw makeError(
            ErrorCode.BUILTIN_NODE_RESOLUTION_FAILED,
            `The builtin node resolution algorithm was unable to resolve the requested module (it didn't go through the pnp resolver because the issuer doesn't seem to be part of the Yarn-managed dependency tree).

Require path: "${requestForDisplay}"
Required by: ${issuerForDisplay}
`,
            { request: requestForDisplay, issuer: issuerForDisplay }
          );
        }
        return npath.toPortablePath(result);
      }
      const issuerInformation = getPackageInformationSafe(issuerLocator);
      let dependencyReference = issuerInformation.packageDependencies.get(dependencyName);
      let fallbackReference = null;
      if (dependencyReference == null) {
        if (issuerLocator.name !== null) {
          const exclusionEntry = runtimeState.fallbackExclusionList.get(issuerLocator.name);
          const canUseFallbacks = !exclusionEntry || !exclusionEntry.has(issuerLocator.reference);
          if (canUseFallbacks) {
            for (let t = 0, T = fallbackLocators.length; t < T; ++t) {
              const fallbackInformation = getPackageInformationSafe(fallbackLocators[t]);
              const reference = fallbackInformation.packageDependencies.get(dependencyName);
              if (reference == null)
                continue;
              if (alwaysWarnOnFallback)
                fallbackReference = reference;
              else
                dependencyReference = reference;
              break;
            }
            if (runtimeState.enableTopLevelFallback) {
              if (dependencyReference == null && fallbackReference === null) {
                const reference = runtimeState.fallbackPool.get(dependencyName);
                if (reference != null) {
                  fallbackReference = reference;
                }
              }
            }
          }
        }
      }
      let error = null;
      if (dependencyReference === null) {
        if (isDependencyTreeRoot(issuerLocator)) {
          error = makeError(
            ErrorCode.MISSING_PEER_DEPENDENCY,
            `Your application tried to access ${dependencyName} (a peer dependency); this isn't allowed as there is no ancestor to satisfy the requirement. Use a devDependency if needed.

Required package: ${dependencyName}${dependencyName !== requestForDisplay ? ` (via "${requestForDisplay}")` : ``}
Required by: ${issuerForDisplay}
`,
            { request: requestForDisplay, issuer: issuerForDisplay, dependencyName }
          );
        } else {
          const brokenAncestors = findBrokenPeerDependencies(dependencyName, issuerLocator);
          if (brokenAncestors.every((ancestor) => isDependencyTreeRoot(ancestor))) {
            error = makeError(
              ErrorCode.MISSING_PEER_DEPENDENCY,
              `${issuerLocator.name} tried to access ${dependencyName} (a peer dependency) but it isn't provided by your application; this makes the require call ambiguous and unsound.

Required package: ${dependencyName}${dependencyName !== requestForDisplay ? ` (via "${requestForDisplay}")` : ``}
Required by: ${issuerLocator.name}@${issuerLocator.reference} (via ${issuerForDisplay})
${brokenAncestors.map((ancestorLocator) => `Ancestor breaking the chain: ${ancestorLocator.name}@${ancestorLocator.reference}
`).join(``)}
`,
              { request: requestForDisplay, issuer: issuerForDisplay, issuerLocator: Object.assign({}, issuerLocator), dependencyName, brokenAncestors }
            );
          } else {
            error = makeError(
              ErrorCode.MISSING_PEER_DEPENDENCY,
              `${issuerLocator.name} tried to access ${dependencyName} (a peer dependency) but it isn't provided by its ancestors; this makes the require call ambiguous and unsound.

Required package: ${dependencyName}${dependencyName !== requestForDisplay ? ` (via "${requestForDisplay}")` : ``}
Required by: ${issuerLocator.name}@${issuerLocator.reference} (via ${issuerForDisplay})

${brokenAncestors.map((ancestorLocator) => `Ancestor breaking the chain: ${ancestorLocator.name}@${ancestorLocator.reference}
`).join(``)}
`,
              { request: requestForDisplay, issuer: issuerForDisplay, issuerLocator: Object.assign({}, issuerLocator), dependencyName, brokenAncestors }
            );
          }
        }
      } else if (dependencyReference === void 0) {
        if (!considerBuiltins && module$1.isBuiltin(request)) {
          if (isDependencyTreeRoot(issuerLocator)) {
            error = makeError(
              ErrorCode.UNDECLARED_DEPENDENCY,
              `Your application tried to access ${dependencyName}. While this module is usually interpreted as a Node builtin, your resolver is running inside a non-Node resolution context where such builtins are ignored. Since ${dependencyName} isn't otherwise declared in your dependencies, this makes the require call ambiguous and unsound.

Required package: ${dependencyName}${dependencyName !== requestForDisplay ? ` (via "${requestForDisplay}")` : ``}
Required by: ${issuerForDisplay}
`,
              { request: requestForDisplay, issuer: issuerForDisplay, dependencyName }
            );
          } else {
            error = makeError(
              ErrorCode.UNDECLARED_DEPENDENCY,
              `${issuerLocator.name} tried to access ${dependencyName}. While this module is usually interpreted as a Node builtin, your resolver is running inside a non-Node resolution context where such builtins are ignored. Since ${dependencyName} isn't otherwise declared in ${issuerLocator.name}'s dependencies, this makes the require call ambiguous and unsound.

Required package: ${dependencyName}${dependencyName !== requestForDisplay ? ` (via "${requestForDisplay}")` : ``}
Required by: ${issuerForDisplay}
`,
              { request: requestForDisplay, issuer: issuerForDisplay, issuerLocator: Object.assign({}, issuerLocator), dependencyName }
            );
          }
        } else {
          if (isDependencyTreeRoot(issuerLocator)) {
            error = makeError(
              ErrorCode.UNDECLARED_DEPENDENCY,
              `Your application tried to access ${dependencyName}, but it isn't declared in your dependencies; this makes the require call ambiguous and unsound.

Required package: ${dependencyName}${dependencyName !== requestForDisplay ? ` (via "${requestForDisplay}")` : ``}
Required by: ${issuerForDisplay}
`,
              { request: requestForDisplay, issuer: issuerForDisplay, dependencyName }
            );
          } else {
            error = makeError(
              ErrorCode.UNDECLARED_DEPENDENCY,
              `${issuerLocator.name} tried to access ${dependencyName}, but it isn't declared in its dependencies; this makes the require call ambiguous and unsound.

Required package: ${dependencyName}${dependencyName !== requestForDisplay ? ` (via "${requestForDisplay}")` : ``}
Required by: ${issuerLocator.name}@${issuerLocator.reference} (via ${issuerForDisplay})
`,
              { request: requestForDisplay, issuer: issuerForDisplay, issuerLocator: Object.assign({}, issuerLocator), dependencyName }
            );
          }
        }
      }
      if (dependencyReference == null) {
        if (fallbackReference === null || error === null)
          throw error || new Error(`Assertion failed: Expected an error to have been set`);
        dependencyReference = fallbackReference;
        const message = error.message.replace(/\n.*/g, ``);
        error.message = message;
        if (!emittedWarnings.has(message) && debugLevel !== 0) {
          emittedWarnings.add(message);
          process.emitWarning(error);
        }
      }
      const dependencyLocator = Array.isArray(dependencyReference) ? { name: dependencyReference[0], reference: dependencyReference[1] } : { name: dependencyName, reference: dependencyReference };
      const dependencyInformation = getPackageInformationSafe(dependencyLocator);
      if (!dependencyInformation.packageLocation) {
        throw makeError(
          ErrorCode.MISSING_DEPENDENCY,
          `A dependency seems valid but didn't get installed for some reason. This might be caused by a partial install, such as dev vs prod.

Required package: ${dependencyLocator.name}@${dependencyLocator.reference}${dependencyLocator.name !== requestForDisplay ? ` (via "${requestForDisplay}")` : ``}
Required by: ${issuerLocator.name}@${issuerLocator.reference} (via ${issuerForDisplay})
`,
          { request: requestForDisplay, issuer: issuerForDisplay, dependencyLocator: Object.assign({}, dependencyLocator) }
        );
      }
      const dependencyLocation = dependencyInformation.packageLocation;
      if (subPath) {
        unqualifiedPath = ppath.join(dependencyLocation, subPath);
      } else {
        unqualifiedPath = dependencyLocation;
      }
    }
    return ppath.normalize(unqualifiedPath);
  }
  function resolveUnqualifiedExport(request, unqualifiedPath, conditions = defaultExportsConditions, issuer) {
    if (isStrictRegExp.test(request))
      return unqualifiedPath;
    const unqualifiedExportPath = applyNodeExportsResolution(unqualifiedPath, conditions, issuer);
    if (unqualifiedExportPath) {
      return ppath.normalize(unqualifiedExportPath);
    } else {
      return unqualifiedPath;
    }
  }
  function resolveUnqualified(unqualifiedPath, { extensions = Object.keys(module$1.Module._extensions) } = {}) {
    const candidates = [];
    const qualifiedPath = applyNodeExtensionResolution(unqualifiedPath, candidates, { extensions });
    if (qualifiedPath) {
      return ppath.normalize(qualifiedPath);
    } else {
      reportRequiredFilesToWatchMode(candidates.map((candidate) => npath.fromPortablePath(candidate)));
      const unqualifiedPathForDisplay = getPathForDisplay(unqualifiedPath);
      const containingPackage = findPackageLocator(unqualifiedPath);
      if (containingPackage) {
        const { packageLocation } = getPackageInformationSafe(containingPackage);
        let exists = true;
        try {
          opts.fakeFs.accessSync(packageLocation);
        } catch (err) {
          if (err?.code === `ENOENT`) {
            exists = false;
          } else {
            const readableError = (err?.message ?? err ?? `empty exception thrown`).replace(/^[A-Z]/, ($0) => $0.toLowerCase());
            throw makeError(ErrorCode.QUALIFIED_PATH_RESOLUTION_FAILED, `Required package exists but could not be accessed (${readableError}).

Missing package: ${containingPackage.name}@${containingPackage.reference}
Expected package location: ${getPathForDisplay(packageLocation)}
`, { unqualifiedPath: unqualifiedPathForDisplay, extensions });
          }
        }
        if (!exists) {
          const errorMessage = packageLocation.includes(`/unplugged/`) ? `Required unplugged package missing from disk. This may happen when switching branches without running installs (unplugged packages must be fully materialized on disk to work).` : `Required package missing from disk. If you keep your packages inside your repository then restarting the Node process may be enough. Otherwise, try to run an install first.`;
          throw makeError(
            ErrorCode.QUALIFIED_PATH_RESOLUTION_FAILED,
            `${errorMessage}

Missing package: ${containingPackage.name}@${containingPackage.reference}
Expected package location: ${getPathForDisplay(packageLocation)}
`,
            { unqualifiedPath: unqualifiedPathForDisplay, extensions }
          );
        }
      }
      throw makeError(
        ErrorCode.QUALIFIED_PATH_RESOLUTION_FAILED,
        `Qualified path resolution failed: we looked for the following paths, but none could be accessed.

Source path: ${unqualifiedPathForDisplay}
${candidates.map((candidate) => `Not found: ${getPathForDisplay(candidate)}
`).join(``)}`,
        { unqualifiedPath: unqualifiedPathForDisplay, extensions }
      );
    }
  }
  function resolvePrivateRequest(request, issuer, opts2) {
    if (!issuer)
      throw new Error(`Assertion failed: An issuer is required to resolve private import mappings`);
    const resolved = packageImportsResolve({
      name: request,
      base: url.pathToFileURL(npath.fromPortablePath(issuer)),
      conditions: opts2.conditions ?? defaultExportsConditions,
      readFileSyncFn: tryReadFile
    });
    if (resolved instanceof URL) {
      return resolveUnqualified(npath.toPortablePath(url.fileURLToPath(resolved)), { extensions: opts2.extensions });
    } else {
      if (resolved.startsWith(`#`))
        throw new Error(`Mapping from one private import to another isn't allowed`);
      return resolveRequest(resolved, issuer, opts2);
    }
  }
  function resolveRequest(request, issuer, opts2 = {}) {
    try {
      if (request.startsWith(`#`))
        return resolvePrivateRequest(request, issuer, opts2);
      const { considerBuiltins, extensions, conditions } = opts2;
      const unqualifiedPath = resolveToUnqualified(request, issuer, { considerBuiltins });
      if (request === `pnpapi`)
        return unqualifiedPath;
      if (unqualifiedPath === null)
        return null;
      const isIssuerIgnored = () => issuer !== null ? isPathIgnored(issuer) : false;
      const remappedPath = (!considerBuiltins || !module$1.isBuiltin(request)) && !isIssuerIgnored() ? resolveUnqualifiedExport(request, unqualifiedPath, conditions, issuer) : unqualifiedPath;
      return resolveUnqualified(remappedPath, { extensions });
    } catch (error) {
      if (Object.hasOwn(error, `pnpCode`))
        Object.assign(error.data, { request: getPathForDisplay(request), issuer: issuer && getPathForDisplay(issuer) });
      throw error;
    }
  }
  function resolveVirtual(request) {
    const normalized = ppath.normalize(request);
    const resolved = VirtualFS.resolveVirtual(normalized);
    return resolved !== normalized ? resolved : null;
  }
  return {
    VERSIONS,
    topLevel,
    getLocator: (name, referencish) => {
      if (Array.isArray(referencish)) {
        return { name: referencish[0], reference: referencish[1] };
      } else {
        return { name, reference: referencish };
      }
    },
    getDependencyTreeRoots: () => {
      return [...runtimeState.dependencyTreeRoots];
    },
    getAllLocators() {
      const locators = [];
      for (const [name, entry] of packageRegistry)
        for (const reference of entry.keys())
          if (name !== null && reference !== null)
            locators.push({ name, reference });
      return locators;
    },
    getPackageInformation: (locator) => {
      const info = getPackageInformation(locator);
      if (info === null)
        return null;
      const packageLocation = npath.fromPortablePath(info.packageLocation);
      const nativeInfo = { ...info, packageLocation };
      return nativeInfo;
    },
    findPackageLocator: (path) => {
      return findPackageLocator(npath.toPortablePath(path));
    },
    resolveToUnqualified: maybeLog(`resolveToUnqualified`, (request, issuer, opts2) => {
      const portableIssuer = issuer !== null ? npath.toPortablePath(issuer) : null;
      const resolution = resolveToUnqualified(npath.toPortablePath(request), portableIssuer, opts2);
      if (resolution === null)
        return null;
      return npath.fromPortablePath(resolution);
    }),
    resolveUnqualified: maybeLog(`resolveUnqualified`, (unqualifiedPath, opts2) => {
      return npath.fromPortablePath(resolveUnqualified(npath.toPortablePath(unqualifiedPath), opts2));
    }),
    resolveRequest: maybeLog(`resolveRequest`, (request, issuer, opts2) => {
      const portableIssuer = issuer !== null ? npath.toPortablePath(issuer) : null;
      const resolution = resolveRequest(npath.toPortablePath(request), portableIssuer, opts2);
      if (resolution === null)
        return null;
      return npath.fromPortablePath(resolution);
    }),
    resolveVirtual: maybeLog(`resolveVirtual`, (path) => {
      const result = resolveVirtual(npath.toPortablePath(path));
      if (result !== null) {
        return npath.fromPortablePath(result);
      } else {
        return null;
      }
    })
  };
}

async function hydratePnpFile(location, { fakeFs, pnpapiResolution }) {
  const source = await fakeFs.readFilePromise(location, `utf8`);
  return hydratePnpSource(source, {
    basePath: path.dirname(location),
    fakeFs,
    pnpapiResolution
  });
}
function hydratePnpSource(source, { basePath, fakeFs, pnpapiResolution }) {
  const data = JSON.parse(source);
  const runtimeState = hydrateRuntimeState(data, {
    basePath
  });
  return makeApi(runtimeState, {
    compatibilityMode: true,
    fakeFs,
    pnpapiResolution
  });
}

const makeRuntimeApi = (settings, basePath, fakeFs) => {
  const data = generateSerializedState(settings);
  const state = hydrateRuntimeState(data, { basePath });
  const pnpapiResolution = npath.join(basePath, Filename.pnpCjs);
  return makeApi(state, { fakeFs, pnpapiResolution });
};

let hook;
var builtLoader = () => {
  if (typeof hook === `undefined`)
    hook = require$$0__default.default.brotliDecompressSync(Buffer.from("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", "base64")).toString();
  return hook;
};

exports.LinkType = LinkType;
exports.generateInlinedScript = generateInlinedScript;
exports.generateLoader = generateLoader;
exports.generatePrettyJson = generatePrettyJson;
exports.generateSplitScript = generateSplitScript;
exports.getESMLoaderTemplate = builtLoader;
exports.hydratePnpFile = hydratePnpFile;
exports.hydratePnpSource = hydratePnpSource;
exports.makeRuntimeApi = makeRuntimeApi;
