"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getRegistry = void 0;
const cli_1 = require("@yarnpkg/cli");
const core_1 = require("@yarnpkg/core");
const core_2 = require("@yarnpkg/core");
const plugin_npm_1 = require("@yarnpkg/plugin-npm");
const clipanion_1 = require("clipanion");
const enquirer_1 = require("enquirer");
// eslint-disable-next-line arca/no-default-export
class NpmLoginCommand extends cli_1.BaseCommand {
    constructor() {
        super(...arguments);
        this.scope = clipanion_1.Option.String(`-s,--scope`, {
            description: `Login to the registry configured for a given scope`,
        });
        this.publish = clipanion_1.Option.Boolean(`--publish`, false, {
            description: `Login to the publish registry`,
        });
        this.alwaysAuth = clipanion_1.Option.Boolean(`--always-auth`, {
            description: `Set the npmAlwaysAuth configuration`,
        });
    }
    async execute() {
        const configuration = await core_1.Configuration.find(this.context.cwd, this.context.plugins);
        const registry = await getRegistry({
            configuration,
            cwd: this.context.cwd,
            publish: this.publish,
            scope: this.scope,
        });
        const report = await core_2.StreamReport.start({
            configuration,
            stdout: this.context.stdout,
            includeFooter: false,
        }, async (report) => {
            const credentials = await getCredentials({
                configuration,
                registry,
                report,
                stdin: this.context.stdin,
                stdout: this.context.stdout,
            });
            const token = await registerOrLogin(registry, credentials, configuration);
            await setAuthToken(registry, token, { alwaysAuth: this.alwaysAuth, scope: this.scope });
            return report.reportInfo(core_1.MessageName.UNNAMED, `Successfully logged in`);
        });
        return report.exitCode();
    }
}
NpmLoginCommand.paths = [
    [`npm`, `login`],
];
NpmLoginCommand.usage = clipanion_1.Command.Usage({
    category: `Npm-related commands`,
    description: `store new login info to access the npm registry`,
    details: `
      This command will ask you for your username, password, and 2FA One-Time-Password (when it applies). It will then modify your local configuration (in your home folder, never in the project itself) to reference the new tokens thus generated.

      Adding the \`-s,--scope\` flag will cause the authentication to be done against whatever registry is configured for the associated scope (see also \`npmScopes\`).

      Adding the \`--publish\` flag will cause the authentication to be done against the registry used when publishing the package (see also \`publishConfig.registry\` and \`npmPublishRegistry\`).
    `,
    examples: [[
            `Login to the default registry`,
            `yarn npm login`,
        ], [
            `Login to the registry linked to the @my-scope registry`,
            `yarn npm login --scope my-scope`,
        ], [
            `Login to the publish registry for the current package`,
            `yarn npm login --publish`,
        ]],
});
exports.default = NpmLoginCommand;
async function getRegistry({ scope, publish, configuration, cwd }) {
    if (scope && publish)
        return plugin_npm_1.npmConfigUtils.getScopeRegistry(scope, { configuration, type: plugin_npm_1.npmConfigUtils.RegistryType.PUBLISH_REGISTRY });
    if (scope)
        return plugin_npm_1.npmConfigUtils.getScopeRegistry(scope, { configuration });
    if (publish)
        return plugin_npm_1.npmConfigUtils.getPublishRegistry((await (0, cli_1.openWorkspace)(configuration, cwd)).manifest, { configuration });
    return plugin_npm_1.npmConfigUtils.getDefaultRegistry({ configuration });
}
exports.getRegistry = getRegistry;
/**
 * Register a new user, or login if the user already exists
 */
async function registerOrLogin(registry, credentials, configuration) {
    // Registration and login are both handled as a `put` by npm. Npm uses a lax
    // endpoint as of 2023-11 where there are no conflicts if the user already
    // exists, but some registries such as Verdaccio are stricter and return a
    // `409 Conflict` status code for existing users. In this case, the client
    // should put a user revision for this specific session (with basic HTTP
    // auth).
    //
    // The code below is based on the logic from the npm client.
    // <https://github.com/npm/npm-profile/blob/30097a5eef4239399b964c2efc121e64e75ecaf5/lib/index.js#L156>.
    const userUrl = `/-/user/org.couchdb.user:${encodeURIComponent(credentials.name)}`;
    const body = {
        _id: `org.couchdb.user:${credentials.name}`,
        name: credentials.name,
        password: credentials.password,
        type: `user`,
        roles: [],
        date: new Date().toISOString(),
    };
    const userOptions = {
        attemptedAs: credentials.name,
        configuration,
        registry,
        jsonResponse: true,
        authType: plugin_npm_1.npmHttpUtils.AuthType.NO_AUTH,
    };
    try {
        const response = await plugin_npm_1.npmHttpUtils.put(userUrl, body, userOptions);
        return response.token;
    }
    catch (error) {
        const isConflict = error.originalError?.name === `HTTPError` && error.originalError?.response.statusCode === 409;
        if (!isConflict) {
            throw error;
        }
    }
    // At this point we did a first request but got a `409 Conflict`. Retrieve
    // the latest state and put a new revision.
    const revOptions = {
        ...userOptions,
        authType: plugin_npm_1.npmHttpUtils.AuthType.NO_AUTH,
        headers: {
            authorization: `Basic ${Buffer.from(`${credentials.name}:${credentials.password}`).toString(`base64`)}`,
        },
    };
    const user = await plugin_npm_1.npmHttpUtils.get(userUrl, revOptions);
    // Update the request body to include the latest fields (such as `_rev`) and
    // the latest `roles` value.
    for (const [k, v] of Object.entries(user)) {
        if (!body[k] || k === `roles`) {
            body[k] = v;
        }
    }
    const revisionUrl = `${userUrl}/-rev/${body._rev}`;
    const response = await plugin_npm_1.npmHttpUtils.put(revisionUrl, body, revOptions);
    return response.token;
}
async function setAuthToken(registry, npmAuthToken, { alwaysAuth, scope }) {
    const makeUpdater = (entryName) => (unknownStore) => {
        const store = core_1.miscUtils.isIndexableObject(unknownStore)
            ? unknownStore
            : {};
        const entryUnknown = store[entryName];
        const entry = core_1.miscUtils.isIndexableObject(entryUnknown)
            ? entryUnknown
            : {};
        return {
            ...store,
            [entryName]: {
                ...entry,
                ...(alwaysAuth !== undefined ? { npmAlwaysAuth: alwaysAuth } : {}),
                npmAuthToken,
            },
        };
    };
    const update = scope
        ? { npmScopes: makeUpdater(scope) }
        : { npmRegistries: makeUpdater(registry) };
    return await core_1.Configuration.updateHomeConfiguration(update);
}
async function getCredentials({ configuration, registry, report, stdin, stdout }) {
    report.reportInfo(core_1.MessageName.UNNAMED, `Logging in to ${core_1.formatUtils.pretty(configuration, registry, core_1.formatUtils.Type.URL)}`);
    let isToken = false;
    if (registry.match(/^https:\/\/npm\.pkg\.github\.com(\/|$)/)) {
        report.reportInfo(core_1.MessageName.UNNAMED, `You seem to be using the GitHub Package Registry. Tokens must be generated with the 'repo', 'write:packages', and 'read:packages' permissions.`);
        isToken = true;
    }
    report.reportSeparator();
    if (configuration.env.YARN_IS_TEST_ENV) {
        return {
            name: configuration.env.YARN_INJECT_NPM_USER || ``,
            password: configuration.env.YARN_INJECT_NPM_PASSWORD || ``,
        };
    }
    const credentials = await (0, enquirer_1.prompt)([{
            type: `input`,
            name: `name`,
            message: `Username:`,
            required: true,
            onCancel: () => process.exit(130),
            stdin,
            stdout,
        }, {
            type: `password`,
            name: `password`,
            message: isToken ? `Token:` : `Password:`,
            required: true,
            onCancel: () => process.exit(130),
            stdin,
            stdout,
        }]);
    report.reportSeparator();
    return credentials;
}
